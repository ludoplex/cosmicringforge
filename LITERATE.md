# Literate Documentation System

**CosmicRingForge — BDE with Models**

## The Enlightened Insight

The format interoperability matrix is not just documentation — it IS the system.

```
Directory Structure = Format Graph = Build Rules = Documentation
```

When you understand this, automation becomes enlightened:
- The Makefile doesn't list files, it discovers formats
- The README isn't written, it's generated from structure
- The workflow isn't documented, it's encoded in relationships
- Conventions aren't rules, they're derived from the format graph

## Full Composability (schemagen v2.0.0)

A single `.schema` file can generate ALL output formats:

```
.schema → schemagen --all → C types      (_types.h, _types.c)
                         → JSON          (_json.h, _json.c)
                         → SQL           (_sql.h, _sql.c)
                         → Protocol Buf  (.proto)
                         → FlatBuffers   (.fbs)
```

The generated `.proto` and `.fbs` can then be processed by Ring 2 tools:

```
.proto → protoc → *.pb-c.c, *.pb-c.h
.fbs   → flatcc → *_builder.c, *_reader.c
```

**All paths lead to C. All C compiles with cosmocc to APE.**

---

## Universal Conventions (Derived from Format Relationships)

### Naming Convention: `{entity}_{role}.{ext}`

The role suffix is determined by the SOURCE format:

| Source Format | Generator | Output Role | Output Pattern |
|---------------|-----------|-------------|----------------|
| `.schema` | schemagen | `_types` | `{name}_types.c`, `{name}_types.h` |
| `.def` | defgen | `_defs` | `{name}_defs.c`, `{name}_defs.h` |
| `.sm` | smgen | `_sm` | `{name}_sm.c`, `{name}_sm.h` |
| `.hsm` | hsmgen | `_hsm` | `{name}_hsm.c`, `{name}_hsm.h` |
| `.lex` | lexgen | `_lex` | `{name}_lex.c`, `{name}_lex.h` |
| `.grammar` | Lemon | `_parse` | `{name}_parse.c`, `{name}_parse.h` |
| `.feature` | bddgen | `_bdd` | `{name}_bdd.c` |
| `.rules` | rulesgen | `_rules` | `{name}_rules.c`, `{name}_rules.h` |
| `.api` | apigen | `_api` | `{name}_api.c`, `{name}_api.h` |
| `.ggo` | gengetopt | `_cli` | `{name}_cli.c`, `{name}_cli.h` |
| `.ui` | uigen | `_ui` | `{name}_ui.c`, `{name}_ui.h` |
| `.proto` | protoc | `_pb` | `{name}.pb-c.c`, `{name}.pb-c.h` |
| `.fbs` | flatcc | `_fbs` | `{name}_builder.c`, `{name}_reader.c` |
| `.drawio` | StateSmith | `_sm` | `{name}_sm.c`, `{name}_sm.h` |
| `.mo` | omc | `_model` | `{name}_model.c` |

### Directory Convention: Layer = Concern

```
specs/
├── domain/        # Data definitions (.schema, .def)
├── behavior/      # State machines (.sm, .hsm)
├── interface/     # External contracts (.api, .ggo, .ui)
├── parsing/       # Language processing (.lex, .grammar)
├── persistence/   # Storage (.sql schemas)
├── serialization/ # Wire formats (.proto, .fbs)
└── testing/       # Verification (.feature)

gen/
├── domain/        # → from specs/domain/
├── behavior/      # → from specs/behavior/
├── interface/     # → from specs/interface/
├── parsing/       # → from specs/parsing/
├── persistence/   # → from specs/persistence/
├── serialization/ # → from specs/serialization/
├── testing/       # → from specs/testing/
└── imported/      # → from model/ (Ring 2)
    ├── statesmith/
    ├── simulink/
    ├── rhapsody/
    ├── openmodelica/
    └── protobuf/
```

### Function Convention: `{Type}_{action}()`

Generated functions follow this pattern:

```c
// From .schema → schemagen
void Example_init(Example *obj);           // Initialize with defaults
bool Example_validate(const Example *obj); // Validate constraints
void Example_copy(Example *dst, const Example *src);
bool Example_eq(const Example *a, const Example *b);

// From .sm → smgen
void Door_sm_init(Door_sm *sm);            // Initialize state machine
void Door_sm_step(Door_sm *sm);            // Process next event
bool Door_sm_is_in(Door_sm *sm, Door_State state);

// From .feature → bddgen
void test_door_open_when_unlocked(void);   // BDD test function
void test_door_stays_locked(void);

// From .api → apigen
int Sensor_api_get(Sensor *out, int id);   // API endpoint
int Sensor_api_list(Sensor **out, int *count);
```

---

## Literate Traceability

### Every Spec File Header
```
/* ═══════════════════════════════════════════════════════════════════════
 * {FILENAME} — {Purpose}
 * ═══════════════════════════════════════════════════════════════════════
 *
 * @layer    {domain|behavior|interface|parsing|testing}
 * @version  {semver}
 * @author   {name}
 *
 * @produces {output files}
 * @consumes {input files/types}
 * @trace    {requirements}
 *
 * ═══════════════════════════════════════════════════════════════════════
 */
```

### Every Generated File Header
```c
/* ═══════════════════════════════════════════════════════════════════════
 * AUTO-GENERATED by {generator} {version} — DO NOT EDIT
 * ═══════════════════════════════════════════════════════════════════════
 *
 * @source   {source_file}:{line_range}
 * @generated {ISO8601_timestamp}
 *
 * @depends  (files this includes)
 *   - gen/domain/base_types.h
 *
 * @usedby   (files that include this)
 *   - gen/testing/example_bdd.c
 *   - src/main.c
 *
 * Regenerate: make regen
 * Verify:     make verify
 *
 * ═══════════════════════════════════════════════════════════════════════
 */
```

### Cross-Reference Tags in Code
```c
/* @source specs/domain/sensor.schema:15-23 */
typedef struct Sensor {
    /* @field temperature - [f32, range: -40..85] */
    float temperature;

    /* @field humidity - [f32, range: 0..100] */
    float humidity;
} Sensor;

/* @feature specs/testing/sensor.feature:12
 * Scenario: Sensor reads valid temperature
 *   Given a calibrated sensor
 *   When temperature is 25.0
 *   Then reading is valid
 */
bool Sensor_validate(const Sensor *s) {
    if (s->temperature < -40.0f || s->temperature > 85.0f) return false;
    if (s->humidity < 0.0f || s->humidity > 100.0f) return false;
    return true;
}
```

---

## Enlightened Automation

### Principle: Structure IS Documentation

The directory structure encodes the format graph:
```
specs/domain/sensor.schema
  ↓ (schemagen discovers this)
gen/domain/sensor_types.c
gen/domain/sensor_types.h
```

This relationship is not documented separately — the Makefile pattern rules ARE the documentation:
```makefile
$(GEN_DIR)/domain/%_types.c: $(SPECS_DIR)/domain/%.schema
	$(BUILD_DIR)/schemagen $< $(GEN_DIR)/domain $*
```

### Principle: Conventions are Computed

Don't document naming conventions as rules. Derive them:

```bash
#!/bin/sh
# scripts/show-conventions.sh - Conventions derived from format graph

echo "File Naming Conventions (derived from generators):"
for gen in schemagen smgen bddgen; do
    if [ -x "build/$gen" ]; then
        echo "  $gen:"
        ./build/$gen --show-naming 2>/dev/null || echo "    (run to see output patterns)"
    fi
done
```

### Principle: Workflow is Format Flow

The workflow isn't a procedure to follow — it's the natural flow of data through formats:

```
Human edits .schema
  ↓ (triggers regen)
schemagen produces _types.c
  ↓ (triggers recompile)
cc produces .o
  ↓ (triggers relink)
app binary updated
  ↓ (triggers test)
BDD tests verify behavior
  ↓ (triggers commit gate)
git diff --exit-code gen/
```

This flow is encoded in Makefile dependencies, not documented separately.

### Principle: README is Generated

```bash
#!/bin/sh
# scripts/gen-readme.sh - Generate README from structure

cat << 'EOF'
# $(basename $(pwd))

## Formats Discovered
EOF

echo "| Format | Count | Generator |"
echo "|--------|-------|-----------|"

count=$(find specs -name "*.schema" | wc -l)
echo "| .schema | $count | schemagen |"

count=$(find specs -name "*.sm" | wc -l)
echo "| .sm | $count | smgen |"

# ... etc
```

---

## The Universal Workflow

There is only ONE workflow, regardless of format:

```
┌────────────────────────────────────────────────────────────────────────────┐
│                        UNIVERSAL WORKFLOW                                   │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│   1. EDIT       spec or model file                                         │
│                 (any format: .schema, .sm, .drawio, .slx, etc.)            │
│                                                                            │
│   2. REGEN      make regen                                                 │
│                 (auto-detects tools, processes all changed formats)        │
│                                                                            │
│   3. VERIFY     make verify                                                │
│                 (regenerates + checks for drift: git diff --exit-code)     │
│                                                                            │
│   4. BUILD      make                                                       │
│                 (compiles all .c to binary, CC=cosmocc for APE)            │
│                                                                            │
│   5. TEST       make test                                                  │
│                 (runs BDD tests from .feature specs)                       │
│                                                                            │
│   6. COMMIT     git add -A && git commit                                   │
│                 (gen/ is tracked, drift gate ensures consistency)          │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

This workflow is the SAME whether you're:
- Editing a `.schema` file with a text editor
- Drawing state machines in `.drawio` with StateSmith
- Building Simulink models in `.slx` with MATLAB
- Writing `.mo` physics models in OpenModelica

The format doesn't matter. The workflow is universal.

---

## Automation Scripts (Enlightened)

### regen-all.sh (Already Implemented)
Discovers formats and processes them with available tools.

### verify-tools.sh
Reports which tools are available for which formats:
```bash
#!/bin/sh
echo "Tool Availability:"
echo "  Ring 0 (always available):"
echo "    schemagen: $([ -x build/schemagen ] && echo 'ready' || echo 'build with make')"
echo "    lemon:     $([ -x build/lemon ] && echo 'ready' || echo 'build with make')"
echo ""
echo "  Ring 2 (auto-detected):"
echo "    StateSmith: $(command -v dotnet >/dev/null && echo 'available' || echo 'not installed')"
echo "    protobuf-c: $(command -v protoc >/dev/null && echo 'available' || echo 'not installed')"
echo "    flatcc:     $(command -v flatcc >/dev/null && echo 'available' || echo 'not installed')"
# ... etc
```

### new-spec.sh
Creates new spec with proper headers:
```bash
#!/bin/sh
# Usage: ./scripts/new-spec.sh domain sensor schema
LAYER=$1
NAME=$2
TYPE=$3

mkdir -p specs/$LAYER
cat > specs/$LAYER/$NAME.$TYPE << EOF
/* ═══════════════════════════════════════════════════════════════════════
 * $NAME.$TYPE — TODO: description
 * ═══════════════════════════════════════════════════════════════════════
 *
 * @layer    $LAYER
 * @version  0.1.0
 * @author   $(git config user.name)
 *
 * @produces gen/$LAYER/${NAME}_*.c, gen/$LAYER/${NAME}_*.h
 *
 * ═══════════════════════════════════════════════════════════════════════
 */

/* TODO: Add your $TYPE definitions here */
EOF

echo "Created specs/$LAYER/$NAME.$TYPE"
echo "Run: make regen"
```

---

## GitHub Template Structure

Based on the format interoperability analysis, the GitHub template should be:

```
cosmicringforge/                    # Template repo
├── .github/
│   ├── workflows/ci.yml            # Verify + build + test
│   └── copilot-instructions.md     # → AGENTS.md
├── .claude/
│   ├── CLAUDE.md                   # LLM context anchor
│   ├── CONVENTIONS.md              # (or derive from structure)
│   └── features/                   # BDD specs for LLM
├── specs/
│   ├── domain/
│   │   └── example.schema          # Template example
│   ├── behavior/
│   ├── interface/
│   ├── parsing/
│   └── testing/
├── model/                          # Ring 2 visual sources
│   ├── statesmith/
│   ├── simulink/
│   └── openmodelica/
├── gen/                            # Generated code (committed)
│   └── domain/
│       ├── example_types.c
│       └── example_types.h
├── tools/
│   ├── schemagen.c
│   ├── lemon.c
│   └── lempar.c
├── src/
│   └── main.c
├── scripts/
│   ├── regen-all.sh
│   ├── template-init.sh
│   └── verify-tools.sh
├── vendor/                         # Vendored libs
├── Makefile                        # Format-driven
├── README.md
├── INTEROP_MATRIX.md               # Format relationships
├── SPEC_TYPES.md                   # Spec type reference
└── LICENSES.md
```

The key insight: **this structure IS the specification**. The Makefile discovers formats from this structure. The README can be generated from this structure. The CI workflow verifies this structure.

---

## Two Protocols: Repo Development vs Template Usage

CosmicRingForge has **two distinct workflows** with separate tooling:

### Protocol 1: Repo Development (this repo itself)

For developing CosmicRingForge generators and infrastructure:

| Component | Purpose |
|-----------|---------|
| `.forge/meta-test.sh` | Test generators, docs, structure |
| `.github/workflows/repo-ci.yml` | CI for repo development |
| `CONTRIBUTING.md` | Contribution guidelines |
| `strict-purist/`, `foss-visual/` | Stack implementations |

**Workflow:**
```
Edit generator → make tools → .forge/meta-test.sh → commit
```

### Protocol 2: Template Usage (after `template-init.sh`)

For engineers using CosmicRingForge as a GitHub template:

| Component | Purpose |
|-----------|---------|
| `scripts/template-init.sh` | Initialize project, remove repo-dev files |
| `scripts/bde-workflow.sh` | BDE workflow commands |
| `scripts/test.sh` | Test user's application |
| `.github/workflows/ci.yml` | CI for user's project (renamed from template-ci.yml) |

**Workflow:**
```
Edit spec → make regen → make verify → make → commit
```

### What template-init.sh Removes

When a user clones the template and runs `./scripts/template-init.sh`:

```bash
# Removed (repo-development only):
.forge/                           # Meta tests
.forge-cache                      # Meta cache
CONTRIBUTING.md                   # Repo contribution guide
.github/workflows/repo-ci.yml     # Repo CI
strict-purist/                    # Stack implementation
foss-visual/                      # Stack implementation
commercial/                       # Stack implementation
vendors/                         # Upstream forks
templates/                        # Template examples
examples/                         # Usage examples
```

### CI Workflow Separation

| Workflow | Triggers | Tests |
|----------|----------|-------|
| `repo-ci.yml` | Changes to tools/, scripts/, .forge/ | Generators, meta-tests, APE build |
| `template-ci.yml` | Push/PR to main | User app, drift check, BDD tests |

---

## Document Version History

| Version | Date | Changes |
|---------|------|---------|
| 2.0.0 | 2026-02-28 | Added composability, two protocols |
| 1.0.0 | 2026-02-27 | Initial version |
