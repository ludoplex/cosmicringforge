# X-Macros in CosmicRingForge

> Define once. Expand everywhere.

## Implementation Status

| Syntax | Status | Generator |
|--------|--------|-----------|
| `TOK(name, lexeme, kind, doc)` | **Implemented** | defgen → `_tokens.h` |
| `TABLE/FIELD/TABLE_END` | **Implemented** | defgen → `_model.h` |
| `SM_STATE/SM_TRANS` | **Implemented** | defgen (state machines) |
| `#define NAME_XMACRO(X)` | **Implemented** | Direct #include (no generator needed) |
| `enum Name { ... }` | *Planned* | High-level DSL → X-macro expansion |
| `flags Name { ... }` | *Planned* | High-level DSL → X-macro expansion |

**Current approach:** Write raw X-macro tables directly in `.def` files (see `procmem.def`).

---

X-Macros are a C preprocessor technique for maintaining consistency across related definitions. They eliminate redundancy by defining data once as a macro that takes another macro as its argument.

## The Problem X-Macros Solve

Without X-Macros, enums require multiple maintenance points:

```c
// BAD: Three places to update when adding LOG_TRACE
typedef enum { LOG_DEBUG, LOG_INFO, LOG_WARN, LOG_ERROR } LogLevel;

const char* log_level_str(LogLevel l) {
    switch(l) {
        case LOG_DEBUG: return "DEBUG";
        case LOG_INFO:  return "INFO";
        case LOG_WARN:  return "WARN";
        case LOG_ERROR: return "ERROR";
    }
}

bool log_level_from_str(const char* s, LogLevel* out) {
    if (strcmp(s, "DEBUG") == 0) { *out = LOG_DEBUG; return true; }
    if (strcmp(s, "INFO") == 0)  { *out = LOG_INFO; return true; }
    // ... more duplication
}
```

## X-Macro Solution

Define the data table once, expand it multiple ways:

```c
/* ═══ X-Macro Table: Single Source of Truth ═══ */
#define LOGLEVEL_XMACRO(X) \
    X(LOG_DEBUG, 0, "DEBUG") \
    X(LOG_INFO,  1, "INFO")  \
    X(LOG_WARN,  2, "WARN")  \
    X(LOG_ERROR, 3, "ERROR")

/* ═══ Expansion 1: Enum Definition ═══ */
typedef enum {
#define X(name, val, str) name = val,
    LOGLEVEL_XMACRO(X)
#undef X
} LogLevel;

/* ═══ Expansion 2: String Lookup ═══ */
static inline const char* log_level_str(LogLevel l) {
    switch(l) {
#define X(name, val, str) case name: return str;
        LOGLEVEL_XMACRO(X)
#undef X
    }
    return "UNKNOWN";
}

/* ═══ Expansion 3: String Parser ═══ */
static inline bool log_level_from_str(const char* s, LogLevel* out) {
#define X(name, val, str) if (strcmp(s, str) == 0) { *out = name; return true; }
    LOGLEVEL_XMACRO(X)
#undef X
    return false;
}

/* ═══ Expansion 4: Validation ═══ */
static inline bool log_level_valid(LogLevel l) {
    switch(l) {
#define X(name, val, str) case name: return true;
        LOGLEVEL_XMACRO(X)
#undef X
    }
    return false;
}

/* ═══ Expansion 5: JSON Serialization ═══ */
static inline void log_level_to_json(LogLevel l, char* buf, size_t n) {
    snprintf(buf, n, "\"%s\"", log_level_str(l));
}
```

## Defgen X-Macro Output

Given this `.def` file:

```
enum LogLevel {
    DEBUG = 0
    INFO = 1
    WARN = 2
    ERROR = 3
}
```

Defgen generates:

**`logging_defs.h`**
```c
/* AUTO-GENERATED by defgen 1.0.0 — DO NOT EDIT */
#ifndef LOGGING_DEFS_H
#define LOGGING_DEFS_H

/* ═══ LogLevel X-Macro Table ═══ */
#define LOGLEVEL_XMACRO(X) \
    X(LOG_DEBUG, 0, "DEBUG") \
    X(LOG_INFO,  1, "INFO")  \
    X(LOG_WARN,  2, "WARN")  \
    X(LOG_ERROR, 3, "ERROR")

/* ═══ LogLevel Enum ═══ */
typedef enum {
#define X(name, val, str) name = val,
    LOGLEVEL_XMACRO(X)
#undef X
    LOG_LEVEL_COUNT
} LogLevel;

/* ═══ LogLevel Functions ═══ */
const char* LogLevel_to_string(LogLevel val);
bool LogLevel_from_string(const char* str, LogLevel* out);
bool LogLevel_validate(LogLevel val);

#endif /* LOGGING_DEFS_H */
```

## Flags X-Macros

Flags (bitmasks) get similar treatment:

```
flags FileMode {
    READ  = 0x01
    WRITE = 0x02
    EXEC  = 0x04
    SHARE = 0x08
}
```

Generates:

```c
#define FILEMODE_XMACRO(X) \
    X(FILE_READ,  0x01, "READ")  \
    X(FILE_WRITE, 0x02, "WRITE") \
    X(FILE_EXEC,  0x04, "EXEC")  \
    X(FILE_SHARE, 0x08, "SHARE")

typedef uint32_t FileMode;
#define X(name, val, str) static const FileMode name = val;
    FILEMODE_XMACRO(X)
#undef X

#define FILEMODE_HAS(flags, flag) (((flags) & (flag)) != 0)

/* Expands flags to string: "READ|WRITE|EXEC" */
size_t FileMode_to_string(FileMode flags, char* buf, size_t n);
```

## Advanced: Multi-Column X-Macros

For richer data, expand the macro columns:

```c
/* name, value, string, json_key, severity_level */
#define ERROR_XMACRO(X) \
    X(ERR_OK,       0,  "OK",           "ok",       0) \
    X(ERR_NOT_FOUND, 1, "Not Found",    "not_found", 1) \
    X(ERR_TIMEOUT,  2,  "Timeout",      "timeout",   2) \
    X(ERR_FATAL,    3,  "Fatal Error",  "fatal",     3)

/* Generate struct array for runtime lookup */
typedef struct {
    int code;
    const char* display;
    const char* json_key;
    int severity;
} ErrorInfo;

static const ErrorInfo g_error_info[] = {
#define X(name, val, str, json, sev) { val, str, json, sev },
    ERROR_XMACRO(X)
#undef X
};
```

## Ring 0 Integration

X-Macros are pure Ring 0 (C preprocessor only):
- No runtime dependencies
- Compiles with any C89+ compiler
- Works with Cosmopolitan/APE
- Zero-cost at runtime (all compile-time expansion)

## When to Use X-Macros

**Use X-Macros for:**
- Enums with string conversion
- Error codes with messages
- Flags/bitmasks with pretty-printing
- Any "table" that needs multiple representations

**Don't use X-Macros for:**
- Simple enums without string conversion
- Runtime-configurable data
- Data that varies per-platform (use `.impl` instead)

## Defgen Options

```
enum LogLevel [xmacro: true, strings: true] {
    DEBUG = 0
    INFO = 1
}
```

Options:
- `xmacro: true` — Generate `_XMACRO(X)` table (default: true)
- `strings: true` — Generate `_to_string()` function (default: true)
- `validate: true` — Generate `_validate()` function (default: true)
- `json: true` — Generate JSON helpers (default: false)
- `prefix: "LOG_"` — Prefix for enum values (default: auto from name)
