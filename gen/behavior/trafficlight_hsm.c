/* AUTO-GENERATED by hsmgen 1.0.0 â€” DO NOT EDIT */

#include "trafficlight_hsm.h"
#include <stddef.h>
#include <string.h>

/* State hierarchy table */
static const TrafficLight_state_info_t state_info[] = {
    {"Operating", "Operating", -1, 0, 1, 1},
    {"Red", "Operating.Red", 0, 1, -1, 0},
    {"Green", "Operating.Green", 0, 1, -1, 0},
    {"Yellow", "Operating.Yellow", 0, 1, -1, 0},
    {"Error", "Error", -1, 0, -1, 0},
};

static const char *event_names[] = {
    "Fault",
    "Timer",
    "Reset",
};

const char *TrafficLight_state_name(TrafficLight_state_t state) {
    if (state >= 0 && state < TrafficLight_STATE_COUNT) return state_info[state].name;
    return "UNKNOWN";
}

const char *TrafficLight_state_path(TrafficLight_state_t state) {
    if (state >= 0 && state < TrafficLight_STATE_COUNT) return state_info[state].full_path;
    return "UNKNOWN";
}

const char *TrafficLight_event_name(TrafficLight_event_t event) {
    if (event >= 0 && event < TrafficLight_EVENT_COUNT) return event_names[event];
    return "UNKNOWN";
}

int TrafficLight_get_parent(TrafficLight_state_t state) {
    if (state >= 0 && state < TrafficLight_STATE_COUNT) return state_info[state].parent;
    return -1;
}

bool TrafficLight_is_in(TrafficLight_context_t *ctx, TrafficLight_state_t state) {
    TrafficLight_state_t current = ctx->current_state;
    while (current >= 0) {
        if (current == state) return true;
        current = (TrafficLight_state_t)state_info[current].parent;
    }
    return false;
}

static void enter_state(TrafficLight_context_t *ctx, TrafficLight_state_t state) {
    /* Build path from root to target */
    TrafficLight_state_t path[8];
    int path_len = 0;
    TrafficLight_state_t s = state;
    while (s >= 0 && path_len < 8) {
        path[path_len++] = s;
        s = (TrafficLight_state_t)state_info[s].parent;
    }
    /* Execute entry actions from root to leaf */
    for (int i = path_len - 1; i >= 0; i--) {
        ctx->current_state = path[i];
        /* Entry action dispatch would go here */
    }
}

void TrafficLight_init(TrafficLight_context_t *ctx, void *user_data) {
    memset(ctx, 0, sizeof(*ctx));
    ctx->user_data = user_data;
    for (int i = 0; i < TrafficLight_STATE_COUNT; i++) {
        ctx->history[i] = (TrafficLight_state_t)-1;
    }
    ctx->current_state = TrafficLight_STATE_OPERATING_RED;
    show_red(ctx); /* Entry action */
}

bool TrafficLight_dispatch(TrafficLight_context_t *ctx, TrafficLight_event_t event) {
    /* Check current state and ancestors for handler */
    TrafficLight_state_t check = ctx->current_state;
    while (check >= 0) {
        switch (check) {
        case TrafficLight_STATE_OPERATING:
            switch (event) {
            case TrafficLight_EVENT_FAULT:
                ctx->current_state = TrafficLight_STATE_ERROR;
                blink_all(ctx); /* Entry */
                return true;
            default: break;
            }
            break;
        case TrafficLight_STATE_OPERATING_RED:
            switch (event) {
            case TrafficLight_EVENT_TIMER:
                ctx->history[0] = ctx->current_state; /* Save history */
                return true;
            default: break;
            }
            break;
        case TrafficLight_STATE_OPERATING_GREEN:
            switch (event) {
            case TrafficLight_EVENT_TIMER:
                ctx->history[0] = ctx->current_state; /* Save history */
                return true;
            default: break;
            }
            break;
        case TrafficLight_STATE_OPERATING_YELLOW:
            switch (event) {
            case TrafficLight_EVENT_TIMER:
                ctx->history[0] = ctx->current_state; /* Save history */
                ctx->current_state = TrafficLight_STATE_OPERATING_RED;
                show_red(ctx); /* Entry */
                return true;
            default: break;
            }
            break;
        case TrafficLight_STATE_ERROR:
            switch (event) {
            case TrafficLight_EVENT_RESET:
                if (ctx->history[0] >= 0) {
                    ctx->current_state = ctx->history[0];
                } else {
                    ctx->current_state = TrafficLight_STATE_OPERATING;
                }
                return true;
            default: break;
            }
            break;
        default: break;
        }
        check = (TrafficLight_state_t)state_info[check].parent;
    }
    return false;
}
