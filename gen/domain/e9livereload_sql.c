/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "e9livereload_sql.h"
#include <string.h>

int E9LiveReloadConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS e9_live_reload_config (\n"
        "    source_dir TEXT,\n"
        "    compiler TEXT,\n"
        "    compiler_flags TEXT,\n"
        "    watch_interval_ms INTEGER,\n"
        "    enable_hot_patch INTEGER,\n"
        "    enable_file_patch INTEGER,\n"
        "    max_patch_size INTEGER,\n"
        "    max_pending_patches INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int E9LiveReloadConfig_insert(sqlite3 *db, const E9LiveReloadConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO e9_live_reload_config (source_dir, compiler, compiler_flags, watch_interval_ms, enable_hot_patch, enable_file_patch, max_patch_size, max_pending_patches) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->source_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->compiler, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->compiler_flags, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->watch_interval_ms);
    sqlite3_bind_int64(stmt, 5, obj->enable_hot_patch);
    sqlite3_bind_int64(stmt, 6, obj->enable_file_patch);
    sqlite3_bind_int64(stmt, 7, obj->max_patch_size);
    sqlite3_bind_int64(stmt, 8, obj->max_pending_patches);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int E9LiveReloadConfig_select_by_id(sqlite3 *db, int64_t id, E9LiveReloadConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM e9_live_reload_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->source_dir, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->source_dir)-1);
    strncpy(obj->compiler, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->compiler)-1);
    strncpy(obj->compiler_flags, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->compiler_flags)-1);
    obj->watch_interval_ms = sqlite3_column_int64(stmt, 3);
    obj->enable_hot_patch = sqlite3_column_int64(stmt, 4);
    obj->enable_file_patch = sqlite3_column_int64(stmt, 5);
    obj->max_patch_size = sqlite3_column_int64(stmt, 6);
    obj->max_pending_patches = sqlite3_column_int64(stmt, 7);
    sqlite3_finalize(stmt);
    return 0;
}

int E9PatchState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS e9_patch_state (\n"
        "    target_path TEXT,\n"
        "    target_mapped INTEGER,\n"
        "    target_size INTEGER,\n"
        "    text_offset INTEGER,\n"
        "    text_rva INTEGER,\n"
        "    text_size INTEGER,\n"
        "    rdata_offset INTEGER,\n"
        "    rdata_rva INTEGER,\n"
        "    rdata_size INTEGER,\n"
        "    data_offset INTEGER,\n"
        "    data_rva INTEGER,\n"
        "    data_size INTEGER,\n"
        "    is_self_patch INTEGER,\n"
        "    exe_path TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int E9PatchState_insert(sqlite3 *db, const E9PatchState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO e9_patch_state (target_path, target_mapped, target_size, text_offset, text_rva, text_size, rdata_offset, rdata_rva, rdata_size, data_offset, data_rva, data_size, is_self_patch, exe_path) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->target_path, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->target_mapped);
    sqlite3_bind_int64(stmt, 3, obj->target_size);
    sqlite3_bind_int64(stmt, 4, obj->text_offset);
    sqlite3_bind_int64(stmt, 5, obj->text_rva);
    sqlite3_bind_int64(stmt, 6, obj->text_size);
    sqlite3_bind_int64(stmt, 7, obj->rdata_offset);
    sqlite3_bind_int64(stmt, 8, obj->rdata_rva);
    sqlite3_bind_int64(stmt, 9, obj->rdata_size);
    sqlite3_bind_int64(stmt, 10, obj->data_offset);
    sqlite3_bind_int64(stmt, 11, obj->data_rva);
    sqlite3_bind_int64(stmt, 12, obj->data_size);
    sqlite3_bind_int64(stmt, 13, obj->is_self_patch);
    sqlite3_bind_text(stmt, 14, obj->exe_path, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int E9PatchState_select_by_id(sqlite3 *db, int64_t id, E9PatchState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM e9_patch_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->target_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->target_path)-1);
    obj->target_mapped = sqlite3_column_int64(stmt, 1);
    obj->target_size = sqlite3_column_int64(stmt, 2);
    obj->text_offset = sqlite3_column_int64(stmt, 3);
    obj->text_rva = sqlite3_column_int64(stmt, 4);
    obj->text_size = sqlite3_column_int64(stmt, 5);
    obj->rdata_offset = sqlite3_column_int64(stmt, 6);
    obj->rdata_rva = sqlite3_column_int64(stmt, 7);
    obj->rdata_size = sqlite3_column_int64(stmt, 8);
    obj->data_offset = sqlite3_column_int64(stmt, 9);
    obj->data_rva = sqlite3_column_int64(stmt, 10);
    obj->data_size = sqlite3_column_int64(stmt, 11);
    obj->is_self_patch = sqlite3_column_int64(stmt, 12);
    strncpy(obj->exe_path, (const char*)sqlite3_column_text(stmt, 13), sizeof(obj->exe_path)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int E9PendingPatch_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS e9_pending_patch (\n"
        "    id INTEGER,\n"
        "    source_file TEXT,\n"
        "    function_name TEXT,\n"
        "    target_type INTEGER,\n"
        "    target_address INTEGER,\n"
        "    old_bytes_size INTEGER,\n"
        "    new_bytes_size INTEGER,\n"
        "    status INTEGER,\n"
        "    error_msg TEXT,\n"
        "    timestamp INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int E9PendingPatch_insert(sqlite3 *db, const E9PendingPatch *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO e9_pending_patch (id, source_file, function_name, target_type, target_address, old_bytes_size, new_bytes_size, status, error_msg, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->id);
    sqlite3_bind_text(stmt, 2, obj->source_file, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->function_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->target_type);
    sqlite3_bind_int64(stmt, 5, obj->target_address);
    sqlite3_bind_int64(stmt, 6, obj->old_bytes_size);
    sqlite3_bind_int64(stmt, 7, obj->new_bytes_size);
    sqlite3_bind_int64(stmt, 8, obj->status);
    sqlite3_bind_text(stmt, 9, obj->error_msg, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 10, obj->timestamp);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int E9PendingPatch_select_by_id(sqlite3 *db, int64_t id, E9PendingPatch *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM e9_pending_patch WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->id = sqlite3_column_int64(stmt, 0);
    strncpy(obj->source_file, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->source_file)-1);
    strncpy(obj->function_name, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->function_name)-1);
    obj->target_type = sqlite3_column_int64(stmt, 3);
    obj->target_address = sqlite3_column_int64(stmt, 4);
    obj->old_bytes_size = sqlite3_column_int64(stmt, 5);
    obj->new_bytes_size = sqlite3_column_int64(stmt, 6);
    obj->status = sqlite3_column_int64(stmt, 7);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 8), sizeof(obj->error_msg)-1);
    obj->timestamp = sqlite3_column_int64(stmt, 9);
    sqlite3_finalize(stmt);
    return 0;
}

int E9LiveReloadSession_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS e9_live_reload_session (\n"
        "    state INTEGER,\n"
        "    total_changes_detected INTEGER,\n"
        "    total_patches_generated INTEGER,\n"
        "    total_patches_applied INTEGER,\n"
        "    total_patches_failed INTEGER,\n"
        "    last_change_time INTEGER,\n"
        "    last_compile_time INTEGER,\n"
        "    last_patch_time INTEGER,\n"
        "    cache_dir TEXT,\n"
        "    num_cached_objects INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int E9LiveReloadSession_insert(sqlite3 *db, const E9LiveReloadSession *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO e9_live_reload_session (state, total_changes_detected, total_patches_generated, total_patches_applied, total_patches_failed, last_change_time, last_compile_time, last_patch_time, cache_dir, num_cached_objects) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->state);
    sqlite3_bind_int64(stmt, 2, obj->total_changes_detected);
    sqlite3_bind_int64(stmt, 3, obj->total_patches_generated);
    sqlite3_bind_int64(stmt, 4, obj->total_patches_applied);
    sqlite3_bind_int64(stmt, 5, obj->total_patches_failed);
    sqlite3_bind_int64(stmt, 6, obj->last_change_time);
    sqlite3_bind_int64(stmt, 7, obj->last_compile_time);
    sqlite3_bind_int64(stmt, 8, obj->last_patch_time);
    sqlite3_bind_text(stmt, 9, obj->cache_dir, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 10, obj->num_cached_objects);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int E9LiveReloadSession_select_by_id(sqlite3 *db, int64_t id, E9LiveReloadSession *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM e9_live_reload_session WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->state = sqlite3_column_int64(stmt, 0);
    obj->total_changes_detected = sqlite3_column_int64(stmt, 1);
    obj->total_patches_generated = sqlite3_column_int64(stmt, 2);
    obj->total_patches_applied = sqlite3_column_int64(stmt, 3);
    obj->total_patches_failed = sqlite3_column_int64(stmt, 4);
    obj->last_change_time = sqlite3_column_int64(stmt, 5);
    obj->last_compile_time = sqlite3_column_int64(stmt, 6);
    obj->last_patch_time = sqlite3_column_int64(stmt, 7);
    strncpy(obj->cache_dir, (const char*)sqlite3_column_text(stmt, 8), sizeof(obj->cache_dir)-1);
    obj->num_cached_objects = sqlite3_column_int64(stmt, 9);
    sqlite3_finalize(stmt);
    return 0;
}

int E9CompilerInvocation_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS e9_compiler_invocation (\n"
        "    source_path TEXT,\n"
        "    object_path TEXT,\n"
        "    exit_code INTEGER,\n"
        "    stdout_size INTEGER,\n"
        "    stderr_size INTEGER,\n"
        "    compile_time_ms INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int E9CompilerInvocation_insert(sqlite3 *db, const E9CompilerInvocation *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO e9_compiler_invocation (source_path, object_path, exit_code, stdout_size, stderr_size, compile_time_ms) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->source_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->object_path, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->exit_code);
    sqlite3_bind_int64(stmt, 4, obj->stdout_size);
    sqlite3_bind_int64(stmt, 5, obj->stderr_size);
    sqlite3_bind_int64(stmt, 6, obj->compile_time_ms);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int E9CompilerInvocation_select_by_id(sqlite3 *db, int64_t id, E9CompilerInvocation *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM e9_compiler_invocation WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->source_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->source_path)-1);
    strncpy(obj->object_path, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->object_path)-1);
    obj->exit_code = sqlite3_column_int64(stmt, 2);
    obj->stdout_size = sqlite3_column_int64(stmt, 3);
    obj->stderr_size = sqlite3_column_int64(stmt, 4);
    obj->compile_time_ms = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

int E9LiveReloadEvent_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS e9_live_reload_event (\n"
        "    event_type INTEGER,\n"
        "    timestamp INTEGER,\n"
        "    file_path TEXT,\n"
        "    patch_id INTEGER,\n"
        "    function_name TEXT,\n"
        "    patch_address INTEGER,\n"
        "    patch_size INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int E9LiveReloadEvent_insert(sqlite3 *db, const E9LiveReloadEvent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO e9_live_reload_event (event_type, timestamp, file_path, patch_id, function_name, patch_address, patch_size, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->event_type);
    sqlite3_bind_int64(stmt, 2, obj->timestamp);
    sqlite3_bind_text(stmt, 3, obj->file_path, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->patch_id);
    sqlite3_bind_text(stmt, 5, obj->function_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->patch_address);
    sqlite3_bind_int64(stmt, 7, obj->patch_size);
    sqlite3_bind_int64(stmt, 8, obj->error_code);
    sqlite3_bind_text(stmt, 9, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int E9LiveReloadEvent_select_by_id(sqlite3 *db, int64_t id, E9LiveReloadEvent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM e9_live_reload_event WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->event_type = sqlite3_column_int64(stmt, 0);
    obj->timestamp = sqlite3_column_int64(stmt, 1);
    strncpy(obj->file_path, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->file_path)-1);
    obj->patch_id = sqlite3_column_int64(stmt, 3);
    strncpy(obj->function_name, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->function_name)-1);
    obj->patch_address = sqlite3_column_int64(stmt, 5);
    obj->patch_size = sqlite3_column_int64(stmt, 6);
    obj->error_code = sqlite3_column_int64(stmt, 7);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 8), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

