/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "livereload_sql.h"
#include <string.h>

int LiveReloadConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS live_reload_config (\n"
        "    source_dir TEXT,\n"
        "    compiler TEXT,\n"
        "    compiler_flags TEXT,\n"
        "    cache_dir TEXT,\n"
        "    watch_interval_ms INTEGER,\n"
        "    enable_hot_patch INTEGER,\n"
        "    enable_file_patch INTEGER,\n"
        "    max_patch_size INTEGER,\n"
        "    max_pending INTEGER,\n"
        "    verbose INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int LiveReloadConfig_insert(sqlite3 *db, const LiveReloadConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO live_reload_config (source_dir, compiler, compiler_flags, cache_dir, watch_interval_ms, enable_hot_patch, enable_file_patch, max_patch_size, max_pending, verbose) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->source_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->compiler, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->compiler_flags, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->cache_dir, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->watch_interval_ms);
    sqlite3_bind_int64(stmt, 6, obj->enable_hot_patch);
    sqlite3_bind_int64(stmt, 7, obj->enable_file_patch);
    sqlite3_bind_int64(stmt, 8, obj->max_patch_size);
    sqlite3_bind_int64(stmt, 9, obj->max_pending);
    sqlite3_bind_int64(stmt, 10, obj->verbose);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int LiveReloadConfig_select_by_id(sqlite3 *db, int64_t id, LiveReloadConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM live_reload_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->source_dir, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->source_dir)-1);
    strncpy(obj->compiler, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->compiler)-1);
    strncpy(obj->compiler_flags, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->compiler_flags)-1);
    strncpy(obj->cache_dir, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->cache_dir)-1);
    obj->watch_interval_ms = sqlite3_column_int64(stmt, 4);
    obj->enable_hot_patch = sqlite3_column_int64(stmt, 5);
    obj->enable_file_patch = sqlite3_column_int64(stmt, 6);
    obj->max_patch_size = sqlite3_column_int64(stmt, 7);
    obj->max_pending = sqlite3_column_int64(stmt, 8);
    obj->verbose = sqlite3_column_int64(stmt, 9);
    sqlite3_finalize(stmt);
    return 0;
}

int FunctionInfo_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS function_info (\n"
        "    name TEXT,\n"
        "    address INTEGER,\n"
        "    size INTEGER,\n"
        "    section TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int FunctionInfo_insert(sqlite3 *db, const FunctionInfo *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO function_info (name, address, size, section) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->address);
    sqlite3_bind_int64(stmt, 3, obj->size);
    sqlite3_bind_text(stmt, 4, obj->section, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int FunctionInfo_select_by_id(sqlite3 *db, int64_t id, FunctionInfo *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM function_info WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->address = sqlite3_column_int64(stmt, 1);
    obj->size = sqlite3_column_int64(stmt, 2);
    strncpy(obj->section, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->section)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int PatchInfo_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS patch_info (\n"
        "    id INTEGER,\n"
        "    function_name TEXT,\n"
        "    target_address INTEGER,\n"
        "    old_size INTEGER,\n"
        "    new_size INTEGER,\n"
        "    status INTEGER,\n"
        "    error_msg TEXT,\n"
        "    timestamp INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int PatchInfo_insert(sqlite3 *db, const PatchInfo *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO patch_info (id, function_name, target_address, old_size, new_size, status, error_msg, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->id);
    sqlite3_bind_text(stmt, 2, obj->function_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->target_address);
    sqlite3_bind_int64(stmt, 4, obj->old_size);
    sqlite3_bind_int64(stmt, 5, obj->new_size);
    sqlite3_bind_int64(stmt, 6, obj->status);
    sqlite3_bind_text(stmt, 7, obj->error_msg, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 8, obj->timestamp);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int PatchInfo_select_by_id(sqlite3 *db, int64_t id, PatchInfo *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM patch_info WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->id = sqlite3_column_int64(stmt, 0);
    strncpy(obj->function_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->function_name)-1);
    obj->target_address = sqlite3_column_int64(stmt, 2);
    obj->old_size = sqlite3_column_int64(stmt, 3);
    obj->new_size = sqlite3_column_int64(stmt, 4);
    obj->status = sqlite3_column_int64(stmt, 5);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->error_msg)-1);
    obj->timestamp = sqlite3_column_int64(stmt, 7);
    sqlite3_finalize(stmt);
    return 0;
}

int LiveReloadSession_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS live_reload_session (\n"
        "    state INTEGER,\n"
        "    target_pid INTEGER,\n"
        "    target_exe TEXT,\n"
        "    changes_detected INTEGER,\n"
        "    patches_generated INTEGER,\n"
        "    patches_applied INTEGER,\n"
        "    patches_failed INTEGER,\n"
        "    patches_reverted INTEGER,\n"
        "    last_change_time INTEGER,\n"
        "    last_compile_time INTEGER,\n"
        "    last_patch_time INTEGER,\n"
        "    cache_dir TEXT,\n"
        "    num_cached INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int LiveReloadSession_insert(sqlite3 *db, const LiveReloadSession *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO live_reload_session (state, target_pid, target_exe, changes_detected, patches_generated, patches_applied, patches_failed, patches_reverted, last_change_time, last_compile_time, last_patch_time, cache_dir, num_cached) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->state);
    sqlite3_bind_int64(stmt, 2, obj->target_pid);
    sqlite3_bind_text(stmt, 3, obj->target_exe, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->changes_detected);
    sqlite3_bind_int64(stmt, 5, obj->patches_generated);
    sqlite3_bind_int64(stmt, 6, obj->patches_applied);
    sqlite3_bind_int64(stmt, 7, obj->patches_failed);
    sqlite3_bind_int64(stmt, 8, obj->patches_reverted);
    sqlite3_bind_int64(stmt, 9, obj->last_change_time);
    sqlite3_bind_int64(stmt, 10, obj->last_compile_time);
    sqlite3_bind_int64(stmt, 11, obj->last_patch_time);
    sqlite3_bind_text(stmt, 12, obj->cache_dir, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 13, obj->num_cached);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int LiveReloadSession_select_by_id(sqlite3 *db, int64_t id, LiveReloadSession *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM live_reload_session WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->state = sqlite3_column_int64(stmt, 0);
    obj->target_pid = sqlite3_column_int64(stmt, 1);
    strncpy(obj->target_exe, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->target_exe)-1);
    obj->changes_detected = sqlite3_column_int64(stmt, 3);
    obj->patches_generated = sqlite3_column_int64(stmt, 4);
    obj->patches_applied = sqlite3_column_int64(stmt, 5);
    obj->patches_failed = sqlite3_column_int64(stmt, 6);
    obj->patches_reverted = sqlite3_column_int64(stmt, 7);
    obj->last_change_time = sqlite3_column_int64(stmt, 8);
    obj->last_compile_time = sqlite3_column_int64(stmt, 9);
    obj->last_patch_time = sqlite3_column_int64(stmt, 10);
    strncpy(obj->cache_dir, (const char*)sqlite3_column_text(stmt, 11), sizeof(obj->cache_dir)-1);
    obj->num_cached = sqlite3_column_int64(stmt, 12);
    sqlite3_finalize(stmt);
    return 0;
}

int CompileResult_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS compile_result (\n"
        "    source_path TEXT,\n"
        "    object_path TEXT,\n"
        "    exit_code INTEGER,\n"
        "    stdout_size INTEGER,\n"
        "    stderr_size INTEGER,\n"
        "    compile_time_ms INTEGER,\n"
        "    success INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int CompileResult_insert(sqlite3 *db, const CompileResult *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO compile_result (source_path, object_path, exit_code, stdout_size, stderr_size, compile_time_ms, success) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->source_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->object_path, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->exit_code);
    sqlite3_bind_int64(stmt, 4, obj->stdout_size);
    sqlite3_bind_int64(stmt, 5, obj->stderr_size);
    sqlite3_bind_int64(stmt, 6, obj->compile_time_ms);
    sqlite3_bind_int64(stmt, 7, obj->success);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int CompileResult_select_by_id(sqlite3 *db, int64_t id, CompileResult *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM compile_result WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->source_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->source_path)-1);
    strncpy(obj->object_path, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->object_path)-1);
    obj->exit_code = sqlite3_column_int64(stmt, 2);
    obj->stdout_size = sqlite3_column_int64(stmt, 3);
    obj->stderr_size = sqlite3_column_int64(stmt, 4);
    obj->compile_time_ms = sqlite3_column_int64(stmt, 5);
    obj->success = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int LiveReloadEvent_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS live_reload_event (\n"
        "    event_type INTEGER,\n"
        "    timestamp INTEGER,\n"
        "    file_path TEXT,\n"
        "    function_name TEXT,\n"
        "    patch_id INTEGER,\n"
        "    patch_address INTEGER,\n"
        "    patch_size INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int LiveReloadEvent_insert(sqlite3 *db, const LiveReloadEvent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO live_reload_event (event_type, timestamp, file_path, function_name, patch_id, patch_address, patch_size, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->event_type);
    sqlite3_bind_int64(stmt, 2, obj->timestamp);
    sqlite3_bind_text(stmt, 3, obj->file_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->function_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->patch_id);
    sqlite3_bind_int64(stmt, 6, obj->patch_address);
    sqlite3_bind_int64(stmt, 7, obj->patch_size);
    sqlite3_bind_int64(stmt, 8, obj->error_code);
    sqlite3_bind_text(stmt, 9, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int LiveReloadEvent_select_by_id(sqlite3 *db, int64_t id, LiveReloadEvent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM live_reload_event WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->event_type = sqlite3_column_int64(stmt, 0);
    obj->timestamp = sqlite3_column_int64(stmt, 1);
    strncpy(obj->file_path, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->file_path)-1);
    strncpy(obj->function_name, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->function_name)-1);
    obj->patch_id = sqlite3_column_int64(stmt, 4);
    obj->patch_address = sqlite3_column_int64(stmt, 5);
    obj->patch_size = sqlite3_column_int64(stmt, 6);
    obj->error_code = sqlite3_column_int64(stmt, 7);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 8), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

