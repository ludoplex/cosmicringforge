/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "bddgen_sql.h"
#include <string.h>

int BddStep_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_step (\n"
        "    keyword INTEGER,\n"
        "    text TEXT,\n"
        "    has_docstring INTEGER,\n"
        "    docstring TEXT,\n"
        "    has_datatable INTEGER,\n"
        "    datatable_rows INTEGER,\n"
        "    datatable_cols INTEGER,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddStep_insert(sqlite3 *db, const BddStep *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_step (keyword, text, has_docstring, docstring, has_datatable, datatable_rows, datatable_cols, line_number) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->keyword);
    sqlite3_bind_text(stmt, 2, obj->text, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->has_docstring);
    sqlite3_bind_text(stmt, 4, obj->docstring, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->has_datatable);
    sqlite3_bind_int64(stmt, 6, obj->datatable_rows);
    sqlite3_bind_int64(stmt, 7, obj->datatable_cols);
    sqlite3_bind_int64(stmt, 8, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddStep_select_by_id(sqlite3 *db, int64_t id, BddStep *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_step WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->keyword = sqlite3_column_int64(stmt, 0);
    strncpy(obj->text, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->text)-1);
    obj->has_docstring = sqlite3_column_int64(stmt, 2);
    strncpy(obj->docstring, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->docstring)-1);
    obj->has_datatable = sqlite3_column_int64(stmt, 4);
    obj->datatable_rows = sqlite3_column_int64(stmt, 5);
    obj->datatable_cols = sqlite3_column_int64(stmt, 6);
    obj->line_number = sqlite3_column_int64(stmt, 7);
    sqlite3_finalize(stmt);
    return 0;
}

int BddDataCell_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_data_cell (\n"
        "    row INTEGER,\n"
        "    col INTEGER,\n"
        "    value TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddDataCell_insert(sqlite3 *db, const BddDataCell *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_data_cell (row, col, value) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->row);
    sqlite3_bind_int64(stmt, 2, obj->col);
    sqlite3_bind_text(stmt, 3, obj->value, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddDataCell_select_by_id(sqlite3 *db, int64_t id, BddDataCell *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_data_cell WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->row = sqlite3_column_int64(stmt, 0);
    obj->col = sqlite3_column_int64(stmt, 1);
    strncpy(obj->value, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->value)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int BddScenario_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_scenario (\n"
        "    name TEXT,\n"
        "    step_count INTEGER,\n"
        "    is_outline INTEGER,\n"
        "    example_count INTEGER,\n"
        "    tags TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddScenario_insert(sqlite3 *db, const BddScenario *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_scenario (name, step_count, is_outline, example_count, tags, line_number) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->step_count);
    sqlite3_bind_int64(stmt, 3, obj->is_outline);
    sqlite3_bind_int64(stmt, 4, obj->example_count);
    sqlite3_bind_text(stmt, 5, obj->tags, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddScenario_select_by_id(sqlite3 *db, int64_t id, BddScenario *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_scenario WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->step_count = sqlite3_column_int64(stmt, 1);
    obj->is_outline = sqlite3_column_int64(stmt, 2);
    obj->example_count = sqlite3_column_int64(stmt, 3);
    strncpy(obj->tags, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->tags)-1);
    obj->line_number = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

int BddBackground_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_background (\n"
        "    step_count INTEGER,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddBackground_insert(sqlite3 *db, const BddBackground *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_background (step_count, line_number) VALUES (?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->step_count);
    sqlite3_bind_int64(stmt, 2, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddBackground_select_by_id(sqlite3 *db, int64_t id, BddBackground *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_background WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->step_count = sqlite3_column_int64(stmt, 0);
    obj->line_number = sqlite3_column_int64(stmt, 1);
    sqlite3_finalize(stmt);
    return 0;
}

int BddExamples_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_examples (\n"
        "    name TEXT,\n"
        "    row_count INTEGER,\n"
        "    col_count INTEGER,\n"
        "    tags TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddExamples_insert(sqlite3 *db, const BddExamples *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_examples (name, row_count, col_count, tags, line_number) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->row_count);
    sqlite3_bind_int64(stmt, 3, obj->col_count);
    sqlite3_bind_text(stmt, 4, obj->tags, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddExamples_select_by_id(sqlite3 *db, int64_t id, BddExamples *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_examples WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->row_count = sqlite3_column_int64(stmt, 1);
    obj->col_count = sqlite3_column_int64(stmt, 2);
    strncpy(obj->tags, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->tags)-1);
    obj->line_number = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int BddFeature_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_feature (\n"
        "    name TEXT,\n"
        "    description TEXT,\n"
        "    scenario_count INTEGER,\n"
        "    has_background INTEGER,\n"
        "    tags TEXT,\n"
        "    language TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddFeature_insert(sqlite3 *db, const BddFeature *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_feature (name, description, scenario_count, has_background, tags, language, line_number) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->description, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->scenario_count);
    sqlite3_bind_int64(stmt, 4, obj->has_background);
    sqlite3_bind_text(stmt, 5, obj->tags, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, obj->language, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddFeature_select_by_id(sqlite3 *db, int64_t id, BddFeature *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_feature WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->description, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->description)-1);
    obj->scenario_count = sqlite3_column_int64(stmt, 2);
    obj->has_background = sqlite3_column_int64(stmt, 3);
    strncpy(obj->tags, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->tags)-1);
    strncpy(obj->language, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->language)-1);
    obj->line_number = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int BddStepPattern_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_step_pattern (\n"
        "    pattern TEXT,\n"
        "    function_name TEXT,\n"
        "    param_count INTEGER,\n"
        "    param_types TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddStepPattern_insert(sqlite3 *db, const BddStepPattern *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_step_pattern (pattern, function_name, param_count, param_types) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->pattern, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->function_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->param_count);
    sqlite3_bind_text(stmt, 4, obj->param_types, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddStepPattern_select_by_id(sqlite3 *db, int64_t id, BddStepPattern *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_step_pattern WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->pattern, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->pattern)-1);
    strncpy(obj->function_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->function_name)-1);
    obj->param_count = sqlite3_column_int64(stmt, 2);
    strncpy(obj->param_types, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->param_types)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int BddTestResult_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_test_result (\n"
        "    scenario_name TEXT,\n"
        "    step_index INTEGER,\n"
        "    status INTEGER,\n"
        "    duration_us INTEGER,\n"
        "    error_message TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddTestResult_insert(sqlite3 *db, const BddTestResult *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_test_result (scenario_name, step_index, status, duration_us, error_message, line_number) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->scenario_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->step_index);
    sqlite3_bind_int64(stmt, 3, obj->status);
    sqlite3_bind_int64(stmt, 4, obj->duration_us);
    sqlite3_bind_text(stmt, 5, obj->error_message, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddTestResult_select_by_id(sqlite3 *db, int64_t id, BddTestResult *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_test_result WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->scenario_name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->scenario_name)-1);
    obj->step_index = sqlite3_column_int64(stmt, 1);
    obj->status = sqlite3_column_int64(stmt, 2);
    obj->duration_us = sqlite3_column_int64(stmt, 3);
    strncpy(obj->error_message, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->error_message)-1);
    obj->line_number = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

int BddParseState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_parse_state (\n"
        "    feature_count INTEGER,\n"
        "    total_scenarios INTEGER,\n"
        "    total_steps INTEGER,\n"
        "    current_line INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddParseState_insert(sqlite3 *db, const BddParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_parse_state (feature_count, total_scenarios, total_steps, current_line, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->feature_count);
    sqlite3_bind_int64(stmt, 2, obj->total_scenarios);
    sqlite3_bind_int64(stmt, 3, obj->total_steps);
    sqlite3_bind_int64(stmt, 4, obj->current_line);
    sqlite3_bind_int64(stmt, 5, obj->error_code);
    sqlite3_bind_text(stmt, 6, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddParseState_select_by_id(sqlite3 *db, int64_t id, BddParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_parse_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->feature_count = sqlite3_column_int64(stmt, 0);
    obj->total_scenarios = sqlite3_column_int64(stmt, 1);
    obj->total_steps = sqlite3_column_int64(stmt, 2);
    obj->current_line = sqlite3_column_int64(stmt, 3);
    obj->error_code = sqlite3_column_int64(stmt, 4);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int BddGenConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS bdd_gen_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    test_framework TEXT,\n"
        "    generate_runner INTEGER,\n"
        "    generate_skeletons INTEGER,\n"
        "    strict_mode INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BddGenConfig_insert(sqlite3 *db, const BddGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO bdd_gen_config (input_path, output_dir, test_framework, generate_runner, generate_skeletons, strict_mode) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->test_framework, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->generate_runner);
    sqlite3_bind_int64(stmt, 5, obj->generate_skeletons);
    sqlite3_bind_int64(stmt, 6, obj->strict_mode);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BddGenConfig_select_by_id(sqlite3 *db, int64_t id, BddGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM bdd_gen_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->test_framework, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->test_framework)-1);
    obj->generate_runner = sqlite3_column_int64(stmt, 3);
    obj->generate_skeletons = sqlite3_column_int64(stmt, 4);
    obj->strict_mode = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

