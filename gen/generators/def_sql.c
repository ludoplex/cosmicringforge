/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "def_sql.h"
#include <string.h>

int DefConstant_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_constant (\n"
        "    name TEXT,\n"
        "    value_type INTEGER,\n"
        "    int_value INTEGER,\n"
        "    float_value REAL,\n"
        "    string_value TEXT,\n"
        "    expr_value TEXT,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefConstant_insert(sqlite3 *db, const DefConstant *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_constant (name, value_type, int_value, float_value, string_value, expr_value, doc_comment) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->value_type);
    sqlite3_bind_int64(stmt, 3, obj->int_value);
    sqlite3_bind_double(stmt, 4, obj->float_value);
    sqlite3_bind_text(stmt, 5, obj->string_value, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, obj->expr_value, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 7, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefConstant_select_by_id(sqlite3 *db, int64_t id, DefConstant *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_constant WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->value_type = sqlite3_column_int64(stmt, 1);
    obj->int_value = sqlite3_column_int64(stmt, 2);
    obj->float_value = sqlite3_column_double(stmt, 3);
    strncpy(obj->string_value, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->string_value)-1);
    strncpy(obj->expr_value, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->expr_value)-1);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefEnumValue_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_enum_value (\n"
        "    name TEXT,\n"
        "    value INTEGER,\n"
        "    auto_value INTEGER,\n"
        "    string_repr TEXT,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefEnumValue_insert(sqlite3 *db, const DefEnumValue *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_enum_value (name, value, auto_value, string_repr, doc_comment) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->value);
    sqlite3_bind_int64(stmt, 3, obj->auto_value);
    sqlite3_bind_text(stmt, 4, obj->string_repr, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefEnumValue_select_by_id(sqlite3 *db, int64_t id, DefEnumValue *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_enum_value WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->value = sqlite3_column_int64(stmt, 1);
    obj->auto_value = sqlite3_column_int64(stmt, 2);
    strncpy(obj->string_repr, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->string_repr)-1);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefEnum_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_enum (\n"
        "    name TEXT,\n"
        "    prefix TEXT,\n"
        "    value_count INTEGER,\n"
        "    underlying_type TEXT,\n"
        "    generate_xmacro INTEGER,\n"
        "    generate_strings INTEGER,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefEnum_insert(sqlite3 *db, const DefEnum *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_enum (name, prefix, value_count, underlying_type, generate_xmacro, generate_strings, doc_comment) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->prefix, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->value_count);
    sqlite3_bind_text(stmt, 4, obj->underlying_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->generate_xmacro);
    sqlite3_bind_int64(stmt, 6, obj->generate_strings);
    sqlite3_bind_text(stmt, 7, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefEnum_select_by_id(sqlite3 *db, int64_t id, DefEnum *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_enum WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->prefix, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->prefix)-1);
    obj->value_count = sqlite3_column_int64(stmt, 2);
    strncpy(obj->underlying_type, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->underlying_type)-1);
    obj->generate_xmacro = sqlite3_column_int64(stmt, 4);
    obj->generate_strings = sqlite3_column_int64(stmt, 5);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefFlagValue_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_flag_value (\n"
        "    name TEXT,\n"
        "    bit_position INTEGER,\n"
        "    explicit_value INTEGER,\n"
        "    string_repr TEXT,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefFlagValue_insert(sqlite3 *db, const DefFlagValue *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_flag_value (name, bit_position, explicit_value, string_repr, doc_comment) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->bit_position);
    sqlite3_bind_int64(stmt, 3, obj->explicit_value);
    sqlite3_bind_text(stmt, 4, obj->string_repr, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefFlagValue_select_by_id(sqlite3 *db, int64_t id, DefFlagValue *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_flag_value WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->bit_position = sqlite3_column_int64(stmt, 1);
    obj->explicit_value = sqlite3_column_int64(stmt, 2);
    strncpy(obj->string_repr, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->string_repr)-1);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefFlags_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_flags (\n"
        "    name TEXT,\n"
        "    prefix TEXT,\n"
        "    flag_count INTEGER,\n"
        "    underlying_type TEXT,\n"
        "    generate_xmacro INTEGER,\n"
        "    generate_has_flag INTEGER,\n"
        "    generate_to_string INTEGER,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefFlags_insert(sqlite3 *db, const DefFlags *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_flags (name, prefix, flag_count, underlying_type, generate_xmacro, generate_has_flag, generate_to_string, doc_comment) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->prefix, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->flag_count);
    sqlite3_bind_text(stmt, 4, obj->underlying_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->generate_xmacro);
    sqlite3_bind_int64(stmt, 6, obj->generate_has_flag);
    sqlite3_bind_int64(stmt, 7, obj->generate_to_string);
    sqlite3_bind_text(stmt, 8, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefFlags_select_by_id(sqlite3 *db, int64_t id, DefFlags *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_flags WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->prefix, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->prefix)-1);
    obj->flag_count = sqlite3_column_int64(stmt, 2);
    strncpy(obj->underlying_type, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->underlying_type)-1);
    obj->generate_xmacro = sqlite3_column_int64(stmt, 4);
    obj->generate_has_flag = sqlite3_column_int64(stmt, 5);
    obj->generate_to_string = sqlite3_column_int64(stmt, 6);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 7), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefConfigField_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_config_field (\n"
        "    name TEXT,\n"
        "    field_type TEXT,\n"
        "    default_value TEXT,\n"
        "    range_min INTEGER,\n"
        "    range_max INTEGER,\n"
        "    has_range INTEGER,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefConfigField_insert(sqlite3 *db, const DefConfigField *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_config_field (name, field_type, default_value, range_min, range_max, has_range, doc_comment) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->field_type, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->default_value, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->range_min);
    sqlite3_bind_int64(stmt, 5, obj->range_max);
    sqlite3_bind_int64(stmt, 6, obj->has_range);
    sqlite3_bind_text(stmt, 7, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefConfigField_select_by_id(sqlite3 *db, int64_t id, DefConfigField *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_config_field WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->field_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->field_type)-1);
    strncpy(obj->default_value, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->default_value)-1);
    obj->range_min = sqlite3_column_int64(stmt, 3);
    obj->range_max = sqlite3_column_int64(stmt, 4);
    obj->has_range = sqlite3_column_int64(stmt, 5);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_config (\n"
        "    name TEXT,\n"
        "    field_count INTEGER,\n"
        "    generate_defaults INTEGER,\n"
        "    generate_validate INTEGER,\n"
        "    generate_from_ini INTEGER,\n"
        "    doc_comment TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefConfig_insert(sqlite3 *db, const DefConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_config (name, field_count, generate_defaults, generate_validate, generate_from_ini, doc_comment) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->field_count);
    sqlite3_bind_int64(stmt, 3, obj->generate_defaults);
    sqlite3_bind_int64(stmt, 4, obj->generate_validate);
    sqlite3_bind_int64(stmt, 5, obj->generate_from_ini);
    sqlite3_bind_text(stmt, 6, obj->doc_comment, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefConfig_select_by_id(sqlite3 *db, int64_t id, DefConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->field_count = sqlite3_column_int64(stmt, 1);
    obj->generate_defaults = sqlite3_column_int64(stmt, 2);
    obj->generate_validate = sqlite3_column_int64(stmt, 3);
    obj->generate_from_ini = sqlite3_column_int64(stmt, 4);
    strncpy(obj->doc_comment, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->doc_comment)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefParseState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_parse_state (\n"
        "    const_count INTEGER,\n"
        "    enum_count INTEGER,\n"
        "    flags_count INTEGER,\n"
        "    config_count INTEGER,\n"
        "    current_line INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefParseState_insert(sqlite3 *db, const DefParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_parse_state (const_count, enum_count, flags_count, config_count, current_line, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->const_count);
    sqlite3_bind_int64(stmt, 2, obj->enum_count);
    sqlite3_bind_int64(stmt, 3, obj->flags_count);
    sqlite3_bind_int64(stmt, 4, obj->config_count);
    sqlite3_bind_int64(stmt, 5, obj->current_line);
    sqlite3_bind_int64(stmt, 6, obj->error_code);
    sqlite3_bind_text(stmt, 7, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefParseState_select_by_id(sqlite3 *db, int64_t id, DefParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_parse_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->const_count = sqlite3_column_int64(stmt, 0);
    obj->enum_count = sqlite3_column_int64(stmt, 1);
    obj->flags_count = sqlite3_column_int64(stmt, 2);
    obj->config_count = sqlite3_column_int64(stmt, 3);
    obj->current_line = sqlite3_column_int64(stmt, 4);
    obj->error_code = sqlite3_column_int64(stmt, 5);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int DefGenConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS def_gen_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    header_guard_prefix TEXT,\n"
        "    xmacro_style INTEGER,\n"
        "    generate_json INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int DefGenConfig_insert(sqlite3 *db, const DefGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO def_gen_config (input_path, output_dir, header_guard_prefix, xmacro_style, generate_json) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->header_guard_prefix, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->xmacro_style);
    sqlite3_bind_int64(stmt, 5, obj->generate_json);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int DefGenConfig_select_by_id(sqlite3 *db, int64_t id, DefGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM def_gen_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->header_guard_prefix, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->header_guard_prefix)-1);
    obj->xmacro_style = sqlite3_column_int64(stmt, 3);
    obj->generate_json = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

