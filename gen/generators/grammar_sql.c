/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "grammar_sql.h"
#include <string.h>

int GrammarToken_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_token (\n"
        "    name TEXT,\n"
        "    value INTEGER,\n"
        "    auto_value INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarToken_insert(sqlite3 *db, const GrammarToken *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_token (name, value, auto_value) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->value);
    sqlite3_bind_int64(stmt, 3, obj->auto_value);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarToken_select_by_id(sqlite3 *db, int64_t id, GrammarToken *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_token WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->value = sqlite3_column_int64(stmt, 1);
    obj->auto_value = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarPrecedence_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_precedence (\n"
        "    level INTEGER,\n"
        "    assoc INTEGER,\n"
        "    token_count INTEGER,\n"
        "    tokens TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarPrecedence_insert(sqlite3 *db, const GrammarPrecedence *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_precedence (level, assoc, token_count, tokens) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->level);
    sqlite3_bind_int64(stmt, 2, obj->assoc);
    sqlite3_bind_int64(stmt, 3, obj->token_count);
    sqlite3_bind_text(stmt, 4, obj->tokens, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarPrecedence_select_by_id(sqlite3 *db, int64_t id, GrammarPrecedence *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_precedence WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->level = sqlite3_column_int64(stmt, 0);
    obj->assoc = sqlite3_column_int64(stmt, 1);
    obj->token_count = sqlite3_column_int64(stmt, 2);
    strncpy(obj->tokens, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->tokens)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarSymbol_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_symbol (\n"
        "    name TEXT,\n"
        "    is_terminal INTEGER,\n"
        "    type_name TEXT,\n"
        "    destructor TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarSymbol_insert(sqlite3 *db, const GrammarSymbol *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_symbol (name, is_terminal, type_name, destructor, line_number) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->is_terminal);
    sqlite3_bind_text(stmt, 3, obj->type_name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->destructor, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarSymbol_select_by_id(sqlite3 *db, int64_t id, GrammarSymbol *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_symbol WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->is_terminal = sqlite3_column_int64(stmt, 1);
    strncpy(obj->type_name, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->type_name)-1);
    strncpy(obj->destructor, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->destructor)-1);
    obj->line_number = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarRule_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_rule (\n"
        "    lhs TEXT,\n"
        "    rhs_count INTEGER,\n"
        "    rhs_symbols TEXT,\n"
        "    rhs_aliases TEXT,\n"
        "    action TEXT,\n"
        "    precedence TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarRule_insert(sqlite3 *db, const GrammarRule *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_rule (lhs, rhs_count, rhs_symbols, rhs_aliases, action, precedence, line_number) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->lhs, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->rhs_count);
    sqlite3_bind_text(stmt, 3, obj->rhs_symbols, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->rhs_aliases, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->action, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, obj->precedence, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarRule_select_by_id(sqlite3 *db, int64_t id, GrammarRule *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_rule WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->lhs, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->lhs)-1);
    obj->rhs_count = sqlite3_column_int64(stmt, 1);
    strncpy(obj->rhs_symbols, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->rhs_symbols)-1);
    strncpy(obj->rhs_aliases, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->rhs_aliases)-1);
    strncpy(obj->action, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->action)-1);
    strncpy(obj->precedence, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->precedence)-1);
    obj->line_number = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarDirective_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_directive (\n"
        "    name TEXT,\n"
        "    value TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarDirective_insert(sqlite3 *db, const GrammarDirective *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_directive (name, value, line_number) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->value, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarDirective_select_by_id(sqlite3 *db, int64_t id, GrammarDirective *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_directive WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->value, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->value)-1);
    obj->line_number = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarDef_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_def (\n"
        "    name TEXT,\n"
        "    start_symbol TEXT,\n"
        "    token_type TEXT,\n"
        "    token_count INTEGER,\n"
        "    rule_count INTEGER,\n"
        "    precedence_levels INTEGER,\n"
        "    has_error_symbol INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarDef_insert(sqlite3 *db, const GrammarDef *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_def (name, start_symbol, token_type, token_count, rule_count, precedence_levels, has_error_symbol) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->start_symbol, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->token_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->token_count);
    sqlite3_bind_int64(stmt, 5, obj->rule_count);
    sqlite3_bind_int64(stmt, 6, obj->precedence_levels);
    sqlite3_bind_int64(stmt, 7, obj->has_error_symbol);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarDef_select_by_id(sqlite3 *db, int64_t id, GrammarDef *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_def WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->start_symbol, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->start_symbol)-1);
    strncpy(obj->token_type, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->token_type)-1);
    obj->token_count = sqlite3_column_int64(stmt, 3);
    obj->rule_count = sqlite3_column_int64(stmt, 4);
    obj->precedence_levels = sqlite3_column_int64(stmt, 5);
    obj->has_error_symbol = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarInclude_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_include (\n"
        "    position INTEGER,\n"
        "    code TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarInclude_insert(sqlite3 *db, const GrammarInclude *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_include (position, code, line_number) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->position);
    sqlite3_bind_text(stmt, 2, obj->code, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarInclude_select_by_id(sqlite3 *db, int64_t id, GrammarInclude *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_include WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->position = sqlite3_column_int64(stmt, 0);
    strncpy(obj->code, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->code)-1);
    obj->line_number = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int GrammarParseState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS grammar_parse_state (\n"
        "    rule_count INTEGER,\n"
        "    symbol_count INTEGER,\n"
        "    conflict_count INTEGER,\n"
        "    current_line INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int GrammarParseState_insert(sqlite3 *db, const GrammarParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO grammar_parse_state (rule_count, symbol_count, conflict_count, current_line, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->rule_count);
    sqlite3_bind_int64(stmt, 2, obj->symbol_count);
    sqlite3_bind_int64(stmt, 3, obj->conflict_count);
    sqlite3_bind_int64(stmt, 4, obj->current_line);
    sqlite3_bind_int64(stmt, 5, obj->error_code);
    sqlite3_bind_text(stmt, 6, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int GrammarParseState_select_by_id(sqlite3 *db, int64_t id, GrammarParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM grammar_parse_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->rule_count = sqlite3_column_int64(stmt, 0);
    obj->symbol_count = sqlite3_column_int64(stmt, 1);
    obj->conflict_count = sqlite3_column_int64(stmt, 2);
    obj->current_line = sqlite3_column_int64(stmt, 3);
    obj->error_code = sqlite3_column_int64(stmt, 4);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int LemonConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS lemon_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    output_base TEXT,\n"
        "    template_file TEXT,\n"
        "    compress INTEGER,\n"
        "    statistics INTEGER,\n"
        "    trace INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int LemonConfig_insert(sqlite3 *db, const LemonConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO lemon_config (input_path, output_dir, output_base, template_file, compress, statistics, trace) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->output_base, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->template_file, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->compress);
    sqlite3_bind_int64(stmt, 6, obj->statistics);
    sqlite3_bind_int64(stmt, 7, obj->trace);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int LemonConfig_select_by_id(sqlite3 *db, int64_t id, LemonConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM lemon_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->output_base, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->output_base)-1);
    strncpy(obj->template_file, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->template_file)-1);
    obj->compress = sqlite3_column_int64(stmt, 4);
    obj->statistics = sqlite3_column_int64(stmt, 5);
    obj->trace = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

