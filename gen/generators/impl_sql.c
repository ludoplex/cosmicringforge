/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "impl_sql.h"
#include <string.h>

int ImplPlatformTarget_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_platform_target (\n"
        "    platform TEXT,\n"
        "    source_file TEXT,\n"
        "    enabled INTEGER,\n"
        "    priority INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplPlatformTarget_insert(sqlite3 *db, const ImplPlatformTarget *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_platform_target (platform, source_file, enabled, priority) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->platform, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->source_file, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->enabled);
    sqlite3_bind_int64(stmt, 4, obj->priority);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplPlatformTarget_select_by_id(sqlite3 *db, int64_t id, ImplPlatformTarget *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_platform_target WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->platform, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->platform)-1);
    strncpy(obj->source_file, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->source_file)-1);
    obj->enabled = sqlite3_column_int64(stmt, 2);
    obj->priority = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplPlatform_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_platform (\n"
        "    name TEXT,\n"
        "    target_count INTEGER,\n"
        "    fallback_file TEXT,\n"
        "    dispatch_style INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplPlatform_insert(sqlite3 *db, const ImplPlatform *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_platform (name, target_count, fallback_file, dispatch_style) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->target_count);
    sqlite3_bind_text(stmt, 3, obj->fallback_file, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->dispatch_style);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplPlatform_select_by_id(sqlite3 *db, int64_t id, ImplPlatform *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_platform WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->target_count = sqlite3_column_int64(stmt, 1);
    strncpy(obj->fallback_file, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->fallback_file)-1);
    obj->dispatch_style = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplOptimizeFunc_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_optimize_func (\n"
        "    name TEXT,\n"
        "    force_inline INTEGER,\n"
        "    no_inline INTEGER,\n"
        "    hot INTEGER,\n"
        "    cold INTEGER,\n"
        "    pure INTEGER,\n"
        "    const_func INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplOptimizeFunc_insert(sqlite3 *db, const ImplOptimizeFunc *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_optimize_func (name, force_inline, no_inline, hot, cold, pure, const_func) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->force_inline);
    sqlite3_bind_int64(stmt, 3, obj->no_inline);
    sqlite3_bind_int64(stmt, 4, obj->hot);
    sqlite3_bind_int64(stmt, 5, obj->cold);
    sqlite3_bind_int64(stmt, 6, obj->pure);
    sqlite3_bind_int64(stmt, 7, obj->const_func);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplOptimizeFunc_select_by_id(sqlite3 *db, int64_t id, ImplOptimizeFunc *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_optimize_func WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->force_inline = sqlite3_column_int64(stmt, 1);
    obj->no_inline = sqlite3_column_int64(stmt, 2);
    obj->hot = sqlite3_column_int64(stmt, 3);
    obj->cold = sqlite3_column_int64(stmt, 4);
    obj->pure = sqlite3_column_int64(stmt, 5);
    obj->const_func = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplOptimizeType_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_optimize_type (\n"
        "    name TEXT,\n"
        "    alignment INTEGER,\n"
        "    pack INTEGER,\n"
        "    cache_align INTEGER,\n"
        "    inline_funcs TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplOptimizeType_insert(sqlite3 *db, const ImplOptimizeType *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_optimize_type (name, alignment, pack, cache_align, inline_funcs) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->alignment);
    sqlite3_bind_int64(stmt, 3, obj->pack);
    sqlite3_bind_int64(stmt, 4, obj->cache_align);
    sqlite3_bind_text(stmt, 5, obj->inline_funcs, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplOptimizeType_select_by_id(sqlite3 *db, int64_t id, ImplOptimizeType *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_optimize_type WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->alignment = sqlite3_column_int64(stmt, 1);
    obj->pack = sqlite3_column_int64(stmt, 2);
    obj->cache_align = sqlite3_column_int64(stmt, 3);
    strncpy(obj->inline_funcs, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->inline_funcs)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplOptimize_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_optimize (\n"
        "    func_count INTEGER,\n"
        "    type_count INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplOptimize_insert(sqlite3 *db, const ImplOptimize *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_optimize (func_count, type_count) VALUES (?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->func_count);
    sqlite3_bind_int64(stmt, 2, obj->type_count);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplOptimize_select_by_id(sqlite3 *db, int64_t id, ImplOptimize *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_optimize WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->func_count = sqlite3_column_int64(stmt, 0);
    obj->type_count = sqlite3_column_int64(stmt, 1);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplSimdTarget_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_simd_target (\n"
        "    name TEXT,\n"
        "    enabled INTEGER,\n"
        "    priority INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplSimdTarget_insert(sqlite3 *db, const ImplSimdTarget *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_simd_target (name, enabled, priority) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->enabled);
    sqlite3_bind_int64(stmt, 3, obj->priority);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplSimdTarget_select_by_id(sqlite3 *db, int64_t id, ImplSimdTarget *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_simd_target WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->enabled = sqlite3_column_int64(stmt, 1);
    obj->priority = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplSimd_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_simd (\n"
        "    target_count INTEGER,\n"
        "    fallback TEXT,\n"
        "    runtime_detect INTEGER,\n"
        "    compile_all INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplSimd_insert(sqlite3 *db, const ImplSimd *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_simd (target_count, fallback, runtime_detect, compile_all) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->target_count);
    sqlite3_bind_text(stmt, 2, obj->fallback, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->runtime_detect);
    sqlite3_bind_int64(stmt, 4, obj->compile_all);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplSimd_select_by_id(sqlite3 *db, int64_t id, ImplSimd *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_simd WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->target_count = sqlite3_column_int64(stmt, 0);
    strncpy(obj->fallback, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->fallback)-1);
    obj->runtime_detect = sqlite3_column_int64(stmt, 2);
    obj->compile_all = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplAllocArena_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_alloc_arena (\n"
        "    name TEXT,\n"
        "    initial_size INTEGER,\n"
        "    max_size INTEGER,\n"
        "    alignment INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplAllocArena_insert(sqlite3 *db, const ImplAllocArena *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_alloc_arena (name, initial_size, max_size, alignment) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->initial_size);
    sqlite3_bind_int64(stmt, 3, obj->max_size);
    sqlite3_bind_int64(stmt, 4, obj->alignment);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplAllocArena_select_by_id(sqlite3 *db, int64_t id, ImplAllocArena *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_alloc_arena WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->initial_size = sqlite3_column_int64(stmt, 1);
    obj->max_size = sqlite3_column_int64(stmt, 2);
    obj->alignment = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplAllocPool_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_alloc_pool (\n"
        "    name TEXT,\n"
        "    element_type TEXT,\n"
        "    initial_count INTEGER,\n"
        "    max_count INTEGER,\n"
        "    thread_local INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplAllocPool_insert(sqlite3 *db, const ImplAllocPool *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_alloc_pool (name, element_type, initial_count, max_count, thread_local) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->element_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->initial_count);
    sqlite3_bind_int64(stmt, 4, obj->max_count);
    sqlite3_bind_int64(stmt, 5, obj->thread_local);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplAllocPool_select_by_id(sqlite3 *db, int64_t id, ImplAllocPool *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_alloc_pool WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->element_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->element_type)-1);
    obj->initial_count = sqlite3_column_int64(stmt, 2);
    obj->max_count = sqlite3_column_int64(stmt, 3);
    obj->thread_local = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplAlloc_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_alloc (\n"
        "    arena_count INTEGER,\n"
        "    pool_count INTEGER,\n"
        "    default_allocator TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplAlloc_insert(sqlite3 *db, const ImplAlloc *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_alloc (arena_count, pool_count, default_allocator) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->arena_count);
    sqlite3_bind_int64(stmt, 2, obj->pool_count);
    sqlite3_bind_text(stmt, 3, obj->default_allocator, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplAlloc_select_by_id(sqlite3 *db, int64_t id, ImplAlloc *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_alloc WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->arena_count = sqlite3_column_int64(stmt, 0);
    obj->pool_count = sqlite3_column_int64(stmt, 1);
    strncpy(obj->default_allocator, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->default_allocator)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplError_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_error (\n"
        "    strategy INTEGER,\n"
        "    error_type TEXT,\n"
        "    generate_strerror INTEGER,\n"
        "    log_on_error INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplError_insert(sqlite3 *db, const ImplError *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_error (strategy, error_type, generate_strerror, log_on_error) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->strategy);
    sqlite3_bind_text(stmt, 2, obj->error_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->generate_strerror);
    sqlite3_bind_int64(stmt, 4, obj->log_on_error);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplError_select_by_id(sqlite3 *db, int64_t id, ImplError *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_error WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->strategy = sqlite3_column_int64(stmt, 0);
    strncpy(obj->error_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->error_type)-1);
    obj->generate_strerror = sqlite3_column_int64(stmt, 2);
    obj->log_on_error = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplParseState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_parse_state (\n"
        "    platform_count INTEGER,\n"
        "    optimize_count INTEGER,\n"
        "    simd_count INTEGER,\n"
        "    alloc_count INTEGER,\n"
        "    current_line INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplParseState_insert(sqlite3 *db, const ImplParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_parse_state (platform_count, optimize_count, simd_count, alloc_count, current_line, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->platform_count);
    sqlite3_bind_int64(stmt, 2, obj->optimize_count);
    sqlite3_bind_int64(stmt, 3, obj->simd_count);
    sqlite3_bind_int64(stmt, 4, obj->alloc_count);
    sqlite3_bind_int64(stmt, 5, obj->current_line);
    sqlite3_bind_int64(stmt, 6, obj->error_code);
    sqlite3_bind_text(stmt, 7, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplParseState_select_by_id(sqlite3 *db, int64_t id, ImplParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_parse_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->platform_count = sqlite3_column_int64(stmt, 0);
    obj->optimize_count = sqlite3_column_int64(stmt, 1);
    obj->simd_count = sqlite3_column_int64(stmt, 2);
    obj->alloc_count = sqlite3_column_int64(stmt, 3);
    obj->current_line = sqlite3_column_int64(stmt, 4);
    obj->error_code = sqlite3_column_int64(stmt, 5);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int ImplGenConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS impl_gen_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    target_platform TEXT,\n"
        "    target_simd TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ImplGenConfig_insert(sqlite3 *db, const ImplGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO impl_gen_config (input_path, output_dir, target_platform, target_simd) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->target_platform, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->target_simd, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ImplGenConfig_select_by_id(sqlite3 *db, int64_t id, ImplGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM impl_gen_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->target_platform, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->target_platform)-1);
    strncpy(obj->target_simd, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->target_simd)-1);
    sqlite3_finalize(stmt);
    return 0;
}

