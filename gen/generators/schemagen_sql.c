/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "schemagen_sql.h"
#include <string.h>

int SchemaField_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS schema_field (\n"
        "    name TEXT,\n"
        "    base INTEGER,\n"
        "    struct_name TEXT,\n"
        "    array_size INTEGER,\n"
        "    is_pointer INTEGER,\n"
        "    has_range INTEGER,\n"
        "    range_min INTEGER,\n"
        "    range_max INTEGER,\n"
        "    has_default INTEGER,\n"
        "    default_val INTEGER,\n"
        "    not_empty INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SchemaField_insert(sqlite3 *db, const SchemaField *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO schema_field (name, base, struct_name, array_size, is_pointer, has_range, range_min, range_max, has_default, default_val, not_empty) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->base);
    sqlite3_bind_text(stmt, 3, obj->struct_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->array_size);
    sqlite3_bind_int64(stmt, 5, obj->is_pointer);
    sqlite3_bind_int64(stmt, 6, obj->has_range);
    sqlite3_bind_int64(stmt, 7, obj->range_min);
    sqlite3_bind_int64(stmt, 8, obj->range_max);
    sqlite3_bind_int64(stmt, 9, obj->has_default);
    sqlite3_bind_int64(stmt, 10, obj->default_val);
    sqlite3_bind_int64(stmt, 11, obj->not_empty);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SchemaField_select_by_id(sqlite3 *db, int64_t id, SchemaField *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM schema_field WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->base = sqlite3_column_int64(stmt, 1);
    strncpy(obj->struct_name, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->struct_name)-1);
    obj->array_size = sqlite3_column_int64(stmt, 3);
    obj->is_pointer = sqlite3_column_int64(stmt, 4);
    obj->has_range = sqlite3_column_int64(stmt, 5);
    obj->range_min = sqlite3_column_int64(stmt, 6);
    obj->range_max = sqlite3_column_int64(stmt, 7);
    obj->has_default = sqlite3_column_int64(stmt, 8);
    obj->default_val = sqlite3_column_int64(stmt, 9);
    obj->not_empty = sqlite3_column_int64(stmt, 10);
    sqlite3_finalize(stmt);
    return 0;
}

int SchemaTypeDef_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS schema_type_def (\n"
        "    name TEXT,\n"
        "    field_count INTEGER,\n"
        "    has_json INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SchemaTypeDef_insert(sqlite3 *db, const SchemaTypeDef *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO schema_type_def (name, field_count, has_json) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->field_count);
    sqlite3_bind_int64(stmt, 3, obj->has_json);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SchemaTypeDef_select_by_id(sqlite3 *db, int64_t id, SchemaTypeDef *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM schema_type_def WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->field_count = sqlite3_column_int64(stmt, 1);
    obj->has_json = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int SchemaParseState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS schema_parse_state (\n"
        "    type_count INTEGER,\n"
        "    current_line INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SchemaParseState_insert(sqlite3 *db, const SchemaParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO schema_parse_state (type_count, current_line, error_code, error_msg) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->type_count);
    sqlite3_bind_int64(stmt, 2, obj->current_line);
    sqlite3_bind_int64(stmt, 3, obj->error_code);
    sqlite3_bind_text(stmt, 4, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SchemaParseState_select_by_id(sqlite3 *db, int64_t id, SchemaParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM schema_parse_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->type_count = sqlite3_column_int64(stmt, 0);
    obj->current_line = sqlite3_column_int64(stmt, 1);
    obj->error_code = sqlite3_column_int64(stmt, 2);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int SchemaGenConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS schema_gen_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    profile TEXT,\n"
        "    generate_json INTEGER,\n"
        "    generate_validators INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SchemaGenConfig_insert(sqlite3 *db, const SchemaGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO schema_gen_config (input_path, output_dir, profile, generate_json, generate_validators) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->profile, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->generate_json);
    sqlite3_bind_int64(stmt, 5, obj->generate_validators);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SchemaGenConfig_select_by_id(sqlite3 *db, int64_t id, SchemaGenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM schema_gen_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->profile, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->profile)-1);
    obj->generate_json = sqlite3_column_int64(stmt, 3);
    obj->generate_validators = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

