/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "openmodelica_sql.h"
#include <string.h>

int MoVariable_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_variable (\n"
        "    name TEXT,\n"
        "    var_type INTEGER,\n"
        "    variability INTEGER,\n"
        "    causality INTEGER,\n"
        "    start_value TEXT,\n"
        "    unit TEXT,\n"
        "    display_unit TEXT,\n"
        "    min_value REAL,\n"
        "    max_value REAL,\n"
        "    nominal REAL,\n"
        "    fixed INTEGER,\n"
        "    description TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoVariable_insert(sqlite3 *db, const MoVariable *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_variable (name, var_type, variability, causality, start_value, unit, display_unit, min_value, max_value, nominal, fixed, description) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->var_type);
    sqlite3_bind_int64(stmt, 3, obj->variability);
    sqlite3_bind_int64(stmt, 4, obj->causality);
    sqlite3_bind_text(stmt, 5, obj->start_value, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, obj->unit, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 7, obj->display_unit, -1, SQLITE_STATIC);
    sqlite3_bind_double(stmt, 8, obj->min_value);
    sqlite3_bind_double(stmt, 9, obj->max_value);
    sqlite3_bind_double(stmt, 10, obj->nominal);
    sqlite3_bind_int64(stmt, 11, obj->fixed);
    sqlite3_bind_text(stmt, 12, obj->description, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoVariable_select_by_id(sqlite3 *db, int64_t id, MoVariable *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_variable WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->var_type = sqlite3_column_int64(stmt, 1);
    obj->variability = sqlite3_column_int64(stmt, 2);
    obj->causality = sqlite3_column_int64(stmt, 3);
    strncpy(obj->start_value, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->start_value)-1);
    strncpy(obj->unit, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->unit)-1);
    strncpy(obj->display_unit, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->display_unit)-1);
    obj->min_value = sqlite3_column_double(stmt, 7);
    obj->max_value = sqlite3_column_double(stmt, 8);
    obj->nominal = sqlite3_column_double(stmt, 9);
    obj->fixed = sqlite3_column_int64(stmt, 10);
    strncpy(obj->description, (const char*)sqlite3_column_text(stmt, 11), sizeof(obj->description)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int MoEquation_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_equation (\n"
        "    equation_type INTEGER,\n"
        "    lhs TEXT,\n"
        "    rhs TEXT,\n"
        "    condition TEXT,\n"
        "    is_initial INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoEquation_insert(sqlite3 *db, const MoEquation *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_equation (equation_type, lhs, rhs, condition, is_initial) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->equation_type);
    sqlite3_bind_text(stmt, 2, obj->lhs, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->rhs, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->condition, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->is_initial);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoEquation_select_by_id(sqlite3 *db, int64_t id, MoEquation *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_equation WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->equation_type = sqlite3_column_int64(stmt, 0);
    strncpy(obj->lhs, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->lhs)-1);
    strncpy(obj->rhs, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->rhs)-1);
    strncpy(obj->condition, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->condition)-1);
    obj->is_initial = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int MoConnector_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_connector (\n"
        "    name TEXT,\n"
        "    connector_type TEXT,\n"
        "    is_flow INTEGER,\n"
        "    is_stream INTEGER,\n"
        "    variable_count INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoConnector_insert(sqlite3 *db, const MoConnector *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_connector (name, connector_type, is_flow, is_stream, variable_count) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->connector_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->is_flow);
    sqlite3_bind_int64(stmt, 4, obj->is_stream);
    sqlite3_bind_int64(stmt, 5, obj->variable_count);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoConnector_select_by_id(sqlite3 *db, int64_t id, MoConnector *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_connector WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->connector_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->connector_type)-1);
    obj->is_flow = sqlite3_column_int64(stmt, 2);
    obj->is_stream = sqlite3_column_int64(stmt, 3);
    obj->variable_count = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int MoComponent_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_component (\n"
        "    name TEXT,\n"
        "    type_name TEXT,\n"
        "    is_replaceable INTEGER,\n"
        "    is_final INTEGER,\n"
        "    is_inner INTEGER,\n"
        "    is_outer INTEGER,\n"
        "    modifier_count INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoComponent_insert(sqlite3 *db, const MoComponent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_component (name, type_name, is_replaceable, is_final, is_inner, is_outer, modifier_count) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->type_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->is_replaceable);
    sqlite3_bind_int64(stmt, 4, obj->is_final);
    sqlite3_bind_int64(stmt, 5, obj->is_inner);
    sqlite3_bind_int64(stmt, 6, obj->is_outer);
    sqlite3_bind_int64(stmt, 7, obj->modifier_count);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoComponent_select_by_id(sqlite3 *db, int64_t id, MoComponent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_component WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->type_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->type_name)-1);
    obj->is_replaceable = sqlite3_column_int64(stmt, 2);
    obj->is_final = sqlite3_column_int64(stmt, 3);
    obj->is_inner = sqlite3_column_int64(stmt, 4);
    obj->is_outer = sqlite3_column_int64(stmt, 5);
    obj->modifier_count = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int MoConnection_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_connection (\n"
        "    from_component TEXT,\n"
        "    from_connector TEXT,\n"
        "    to_component TEXT,\n"
        "    to_connector TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoConnection_insert(sqlite3 *db, const MoConnection *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_connection (from_component, from_connector, to_component, to_connector) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->from_component, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->from_connector, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->to_component, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->to_connector, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoConnection_select_by_id(sqlite3 *db, int64_t id, MoConnection *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_connection WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->from_component, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->from_component)-1);
    strncpy(obj->from_connector, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->from_connector)-1);
    strncpy(obj->to_component, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->to_component)-1);
    strncpy(obj->to_connector, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->to_connector)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int MoClass_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_class (\n"
        "    name TEXT,\n"
        "    class_type INTEGER,\n"
        "    is_partial INTEGER,\n"
        "    is_encapsulated INTEGER,\n"
        "    extends_count INTEGER,\n"
        "    variable_count INTEGER,\n"
        "    equation_count INTEGER,\n"
        "    component_count INTEGER,\n"
        "    connection_count INTEGER,\n"
        "    description TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoClass_insert(sqlite3 *db, const MoClass *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_class (name, class_type, is_partial, is_encapsulated, extends_count, variable_count, equation_count, component_count, connection_count, description) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->class_type);
    sqlite3_bind_int64(stmt, 3, obj->is_partial);
    sqlite3_bind_int64(stmt, 4, obj->is_encapsulated);
    sqlite3_bind_int64(stmt, 5, obj->extends_count);
    sqlite3_bind_int64(stmt, 6, obj->variable_count);
    sqlite3_bind_int64(stmt, 7, obj->equation_count);
    sqlite3_bind_int64(stmt, 8, obj->component_count);
    sqlite3_bind_int64(stmt, 9, obj->connection_count);
    sqlite3_bind_text(stmt, 10, obj->description, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoClass_select_by_id(sqlite3 *db, int64_t id, MoClass *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_class WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->class_type = sqlite3_column_int64(stmt, 1);
    obj->is_partial = sqlite3_column_int64(stmt, 2);
    obj->is_encapsulated = sqlite3_column_int64(stmt, 3);
    obj->extends_count = sqlite3_column_int64(stmt, 4);
    obj->variable_count = sqlite3_column_int64(stmt, 5);
    obj->equation_count = sqlite3_column_int64(stmt, 6);
    obj->component_count = sqlite3_column_int64(stmt, 7);
    obj->connection_count = sqlite3_column_int64(stmt, 8);
    strncpy(obj->description, (const char*)sqlite3_column_text(stmt, 9), sizeof(obj->description)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int MoPackage_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_package (\n"
        "    name TEXT,\n"
        "    version TEXT,\n"
        "    class_count INTEGER,\n"
        "    uses_count INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoPackage_insert(sqlite3 *db, const MoPackage *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_package (name, version, class_count, uses_count) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->version, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->class_count);
    sqlite3_bind_int64(stmt, 4, obj->uses_count);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoPackage_select_by_id(sqlite3 *db, int64_t id, MoPackage *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_package WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->version, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->version)-1);
    obj->class_count = sqlite3_column_int64(stmt, 2);
    obj->uses_count = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int MoSimulationConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_simulation_config (\n"
        "    start_time REAL,\n"
        "    stop_time REAL,\n"
        "    step_size REAL,\n"
        "    tolerance REAL,\n"
        "    solver TEXT,\n"
        "    output_format TEXT,\n"
        "    number_of_intervals INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoSimulationConfig_insert(sqlite3 *db, const MoSimulationConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_simulation_config (start_time, stop_time, step_size, tolerance, solver, output_format, number_of_intervals) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_double(stmt, 1, obj->start_time);
    sqlite3_bind_double(stmt, 2, obj->stop_time);
    sqlite3_bind_double(stmt, 3, obj->step_size);
    sqlite3_bind_double(stmt, 4, obj->tolerance);
    sqlite3_bind_text(stmt, 5, obj->solver, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, obj->output_format, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, obj->number_of_intervals);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoSimulationConfig_select_by_id(sqlite3 *db, int64_t id, MoSimulationConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_simulation_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->start_time = sqlite3_column_double(stmt, 0);
    obj->stop_time = sqlite3_column_double(stmt, 1);
    obj->step_size = sqlite3_column_double(stmt, 2);
    obj->tolerance = sqlite3_column_double(stmt, 3);
    strncpy(obj->solver, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->solver)-1);
    strncpy(obj->output_format, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->output_format)-1);
    obj->number_of_intervals = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int OmcCompilerConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS omc_compiler_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    target TEXT,\n"
        "    generate_code INTEGER,\n"
        "    generate_makefile INTEGER,\n"
        "    debug_info INTEGER,\n"
        "    optimize INTEGER,\n"
        "    profiling INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int OmcCompilerConfig_insert(sqlite3 *db, const OmcCompilerConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO omc_compiler_config (input_path, output_dir, target, generate_code, generate_makefile, debug_info, optimize, profiling) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->target, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->generate_code);
    sqlite3_bind_int64(stmt, 5, obj->generate_makefile);
    sqlite3_bind_int64(stmt, 6, obj->debug_info);
    sqlite3_bind_int64(stmt, 7, obj->optimize);
    sqlite3_bind_int64(stmt, 8, obj->profiling);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int OmcCompilerConfig_select_by_id(sqlite3 *db, int64_t id, OmcCompilerConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM omc_compiler_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->target, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->target)-1);
    obj->generate_code = sqlite3_column_int64(stmt, 3);
    obj->generate_makefile = sqlite3_column_int64(stmt, 4);
    obj->debug_info = sqlite3_column_int64(stmt, 5);
    obj->optimize = sqlite3_column_int64(stmt, 6);
    obj->profiling = sqlite3_column_int64(stmt, 7);
    sqlite3_finalize(stmt);
    return 0;
}

int MoFmuConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS mo_fmu_config (\n"
        "    fmu_name TEXT,\n"
        "    fmu_type INTEGER,\n"
        "    fmu_version TEXT,\n"
        "    include_source INTEGER,\n"
        "    platforms TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int MoFmuConfig_insert(sqlite3 *db, const MoFmuConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO mo_fmu_config (fmu_name, fmu_type, fmu_version, include_source, platforms) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->fmu_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->fmu_type);
    sqlite3_bind_text(stmt, 3, obj->fmu_version, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->include_source);
    sqlite3_bind_text(stmt, 5, obj->platforms, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int MoFmuConfig_select_by_id(sqlite3 *db, int64_t id, MoFmuConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM mo_fmu_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->fmu_name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->fmu_name)-1);
    obj->fmu_type = sqlite3_column_int64(stmt, 1);
    strncpy(obj->fmu_version, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->fmu_version)-1);
    obj->include_source = sqlite3_column_int64(stmt, 3);
    strncpy(obj->platforms, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->platforms)-1);
    sqlite3_finalize(stmt);
    return 0;
}

