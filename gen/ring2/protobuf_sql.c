/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "protobuf_sql.h"
#include <string.h>

int ProtoField_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_field (\n"
        "    name TEXT,\n"
        "    field_number INTEGER,\n"
        "    field_type INTEGER,\n"
        "    type_name TEXT,\n"
        "    label INTEGER,\n"
        "    default_value TEXT,\n"
        "    oneof_index INTEGER,\n"
        "    packed INTEGER,\n"
        "    deprecated INTEGER,\n"
        "    json_name TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoField_insert(sqlite3 *db, const ProtoField *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_field (name, field_number, field_type, type_name, label, default_value, oneof_index, packed, deprecated, json_name) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->field_number);
    sqlite3_bind_int64(stmt, 3, obj->field_type);
    sqlite3_bind_text(stmt, 4, obj->type_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, obj->label);
    sqlite3_bind_text(stmt, 6, obj->default_value, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, obj->oneof_index);
    sqlite3_bind_int64(stmt, 8, obj->packed);
    sqlite3_bind_int64(stmt, 9, obj->deprecated);
    sqlite3_bind_text(stmt, 10, obj->json_name, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoField_select_by_id(sqlite3 *db, int64_t id, ProtoField *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_field WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->field_number = sqlite3_column_int64(stmt, 1);
    obj->field_type = sqlite3_column_int64(stmt, 2);
    strncpy(obj->type_name, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->type_name)-1);
    obj->label = sqlite3_column_int64(stmt, 4);
    strncpy(obj->default_value, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->default_value)-1);
    obj->oneof_index = sqlite3_column_int64(stmt, 6);
    obj->packed = sqlite3_column_int64(stmt, 7);
    obj->deprecated = sqlite3_column_int64(stmt, 8);
    strncpy(obj->json_name, (const char*)sqlite3_column_text(stmt, 9), sizeof(obj->json_name)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoMessage_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_message (\n"
        "    name TEXT,\n"
        "    full_name TEXT,\n"
        "    field_count INTEGER,\n"
        "    nested_type_count INTEGER,\n"
        "    enum_type_count INTEGER,\n"
        "    oneof_count INTEGER,\n"
        "    reserved_ranges TEXT,\n"
        "    reserved_names TEXT,\n"
        "    deprecated INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoMessage_insert(sqlite3 *db, const ProtoMessage *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_message (name, full_name, field_count, nested_type_count, enum_type_count, oneof_count, reserved_ranges, reserved_names, deprecated) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->full_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->field_count);
    sqlite3_bind_int64(stmt, 4, obj->nested_type_count);
    sqlite3_bind_int64(stmt, 5, obj->enum_type_count);
    sqlite3_bind_int64(stmt, 6, obj->oneof_count);
    sqlite3_bind_text(stmt, 7, obj->reserved_ranges, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 8, obj->reserved_names, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 9, obj->deprecated);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoMessage_select_by_id(sqlite3 *db, int64_t id, ProtoMessage *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_message WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->full_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->full_name)-1);
    obj->field_count = sqlite3_column_int64(stmt, 2);
    obj->nested_type_count = sqlite3_column_int64(stmt, 3);
    obj->enum_type_count = sqlite3_column_int64(stmt, 4);
    obj->oneof_count = sqlite3_column_int64(stmt, 5);
    strncpy(obj->reserved_ranges, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->reserved_ranges)-1);
    strncpy(obj->reserved_names, (const char*)sqlite3_column_text(stmt, 7), sizeof(obj->reserved_names)-1);
    obj->deprecated = sqlite3_column_int64(stmt, 8);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoEnum_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_enum (\n"
        "    name TEXT,\n"
        "    full_name TEXT,\n"
        "    value_count INTEGER,\n"
        "    allow_alias INTEGER,\n"
        "    deprecated INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoEnum_insert(sqlite3 *db, const ProtoEnum *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_enum (name, full_name, value_count, allow_alias, deprecated) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->full_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->value_count);
    sqlite3_bind_int64(stmt, 4, obj->allow_alias);
    sqlite3_bind_int64(stmt, 5, obj->deprecated);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoEnum_select_by_id(sqlite3 *db, int64_t id, ProtoEnum *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_enum WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->full_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->full_name)-1);
    obj->value_count = sqlite3_column_int64(stmt, 2);
    obj->allow_alias = sqlite3_column_int64(stmt, 3);
    obj->deprecated = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoEnumValue_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_enum_value (\n"
        "    name TEXT,\n"
        "    number INTEGER,\n"
        "    deprecated INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoEnumValue_insert(sqlite3 *db, const ProtoEnumValue *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_enum_value (name, number, deprecated) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->number);
    sqlite3_bind_int64(stmt, 3, obj->deprecated);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoEnumValue_select_by_id(sqlite3 *db, int64_t id, ProtoEnumValue *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_enum_value WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->number = sqlite3_column_int64(stmt, 1);
    obj->deprecated = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoOneof_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_oneof (\n"
        "    name TEXT,\n"
        "    field_count INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoOneof_insert(sqlite3 *db, const ProtoOneof *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_oneof (name, field_count) VALUES (?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->field_count);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoOneof_select_by_id(sqlite3 *db, int64_t id, ProtoOneof *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_oneof WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->field_count = sqlite3_column_int64(stmt, 1);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoService_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_service (\n"
        "    name TEXT,\n"
        "    full_name TEXT,\n"
        "    method_count INTEGER,\n"
        "    deprecated INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoService_insert(sqlite3 *db, const ProtoService *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_service (name, full_name, method_count, deprecated) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->full_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->method_count);
    sqlite3_bind_int64(stmt, 4, obj->deprecated);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoService_select_by_id(sqlite3 *db, int64_t id, ProtoService *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_service WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->full_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->full_name)-1);
    obj->method_count = sqlite3_column_int64(stmt, 2);
    obj->deprecated = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoMethod_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_method (\n"
        "    name TEXT,\n"
        "    input_type TEXT,\n"
        "    output_type TEXT,\n"
        "    client_streaming INTEGER,\n"
        "    server_streaming INTEGER,\n"
        "    deprecated INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoMethod_insert(sqlite3 *db, const ProtoMethod *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_method (name, input_type, output_type, client_streaming, server_streaming, deprecated) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->input_type, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->output_type, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->client_streaming);
    sqlite3_bind_int64(stmt, 5, obj->server_streaming);
    sqlite3_bind_int64(stmt, 6, obj->deprecated);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoMethod_select_by_id(sqlite3 *db, int64_t id, ProtoMethod *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_method WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->input_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->input_type)-1);
    strncpy(obj->output_type, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->output_type)-1);
    obj->client_streaming = sqlite3_column_int64(stmt, 3);
    obj->server_streaming = sqlite3_column_int64(stmt, 4);
    obj->deprecated = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoFile_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_file (\n"
        "    name TEXT,\n"
        "    package TEXT,\n"
        "    syntax TEXT,\n"
        "    message_count INTEGER,\n"
        "    enum_count INTEGER,\n"
        "    service_count INTEGER,\n"
        "    dependency_count INTEGER,\n"
        "    public_dependency_count INTEGER,\n"
        "    weak_dependency_count INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoFile_insert(sqlite3 *db, const ProtoFile *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_file (name, package, syntax, message_count, enum_count, service_count, dependency_count, public_dependency_count, weak_dependency_count) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->package, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->syntax, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->message_count);
    sqlite3_bind_int64(stmt, 5, obj->enum_count);
    sqlite3_bind_int64(stmt, 6, obj->service_count);
    sqlite3_bind_int64(stmt, 7, obj->dependency_count);
    sqlite3_bind_int64(stmt, 8, obj->public_dependency_count);
    sqlite3_bind_int64(stmt, 9, obj->weak_dependency_count);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoFile_select_by_id(sqlite3 *db, int64_t id, ProtoFile *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_file WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->package, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->package)-1);
    strncpy(obj->syntax, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->syntax)-1);
    obj->message_count = sqlite3_column_int64(stmt, 3);
    obj->enum_count = sqlite3_column_int64(stmt, 4);
    obj->service_count = sqlite3_column_int64(stmt, 5);
    obj->dependency_count = sqlite3_column_int64(stmt, 6);
    obj->public_dependency_count = sqlite3_column_int64(stmt, 7);
    obj->weak_dependency_count = sqlite3_column_int64(stmt, 8);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoImport_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_import (\n"
        "    file_path TEXT,\n"
        "    is_public INTEGER,\n"
        "    is_weak INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoImport_insert(sqlite3 *db, const ProtoImport *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_import (file_path, is_public, is_weak) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->file_path, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->is_public);
    sqlite3_bind_int64(stmt, 3, obj->is_weak);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoImport_select_by_id(sqlite3 *db, int64_t id, ProtoImport *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_import WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->file_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->file_path)-1);
    obj->is_public = sqlite3_column_int64(stmt, 1);
    obj->is_weak = sqlite3_column_int64(stmt, 2);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtocCConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS protoc_c_config (\n"
        "    input_path TEXT,\n"
        "    output_dir TEXT,\n"
        "    include_paths TEXT,\n"
        "    generate_rpc INTEGER,\n"
        "    generate_pack INTEGER,\n"
        "    generate_init INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtocCConfig_insert(sqlite3 *db, const ProtocCConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO protoc_c_config (input_path, output_dir, include_paths, generate_rpc, generate_pack, generate_init) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->include_paths, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->generate_rpc);
    sqlite3_bind_int64(stmt, 5, obj->generate_pack);
    sqlite3_bind_int64(stmt, 6, obj->generate_init);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtocCConfig_select_by_id(sqlite3 *db, int64_t id, ProtocCConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM protoc_c_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_dir)-1);
    strncpy(obj->include_paths, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->include_paths)-1);
    obj->generate_rpc = sqlite3_column_int64(stmt, 3);
    obj->generate_pack = sqlite3_column_int64(stmt, 4);
    obj->generate_init = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

int ProtoParseState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS proto_parse_state (\n"
        "    file_count INTEGER,\n"
        "    message_count INTEGER,\n"
        "    enum_count INTEGER,\n"
        "    service_count INTEGER,\n"
        "    error_code INTEGER,\n"
        "    error_msg TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int ProtoParseState_insert(sqlite3 *db, const ProtoParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO proto_parse_state (file_count, message_count, enum_count, service_count, error_code, error_msg) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->file_count);
    sqlite3_bind_int64(stmt, 2, obj->message_count);
    sqlite3_bind_int64(stmt, 3, obj->enum_count);
    sqlite3_bind_int64(stmt, 4, obj->service_count);
    sqlite3_bind_int64(stmt, 5, obj->error_code);
    sqlite3_bind_text(stmt, 6, obj->error_msg, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int ProtoParseState_select_by_id(sqlite3 *db, int64_t id, ProtoParseState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM proto_parse_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->file_count = sqlite3_column_int64(stmt, 0);
    obj->message_count = sqlite3_column_int64(stmt, 1);
    obj->enum_count = sqlite3_column_int64(stmt, 2);
    obj->service_count = sqlite3_column_int64(stmt, 3);
    obj->error_code = sqlite3_column_int64(stmt, 4);
    strncpy(obj->error_msg, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->error_msg)-1);
    sqlite3_finalize(stmt);
    return 0;
}

