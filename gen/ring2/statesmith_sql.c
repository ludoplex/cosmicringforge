/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "statesmith_sql.h"
#include <string.h>

int SmithState_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_state (\n"
        "    name TEXT,\n"
        "    parent TEXT,\n"
        "    initial INTEGER,\n"
        "    final INTEGER,\n"
        "    entry_action TEXT,\n"
        "    exit_action TEXT,\n"
        "    do_action TEXT,\n"
        "    history INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithState_insert(sqlite3 *db, const SmithState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_state (name, parent, initial, final, entry_action, exit_action, do_action, history) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->parent, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->initial);
    sqlite3_bind_int64(stmt, 4, obj->final);
    sqlite3_bind_text(stmt, 5, obj->entry_action, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, obj->exit_action, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 7, obj->do_action, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 8, obj->history);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithState_select_by_id(sqlite3 *db, int64_t id, SmithState *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_state WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->parent, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->parent)-1);
    obj->initial = sqlite3_column_int64(stmt, 2);
    obj->final = sqlite3_column_int64(stmt, 3);
    strncpy(obj->entry_action, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->entry_action)-1);
    strncpy(obj->exit_action, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->exit_action)-1);
    strncpy(obj->do_action, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->do_action)-1);
    obj->history = sqlite3_column_int64(stmt, 7);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithTransition_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_transition (\n"
        "    source TEXT,\n"
        "    target TEXT,\n"
        "    event TEXT,\n"
        "    guard TEXT,\n"
        "    action TEXT,\n"
        "    order INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithTransition_insert(sqlite3 *db, const SmithTransition *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_transition (source, target, event, guard, action, order) VALUES (?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->source, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->target, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->event, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->guard, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->action, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->order);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithTransition_select_by_id(sqlite3 *db, int64_t id, SmithTransition *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_transition WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->source, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->source)-1);
    strncpy(obj->target, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->target)-1);
    strncpy(obj->event, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->event)-1);
    strncpy(obj->guard, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->guard)-1);
    strncpy(obj->action, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->action)-1);
    obj->order = sqlite3_column_int64(stmt, 5);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithEvent_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_event (\n"
        "    name TEXT,\n"
        "    has_data INTEGER,\n"
        "    data_type TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithEvent_insert(sqlite3 *db, const SmithEvent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_event (name, has_data, data_type) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->has_data);
    sqlite3_bind_text(stmt, 3, obj->data_type, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithEvent_select_by_id(sqlite3 *db, int64_t id, SmithEvent *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_event WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->has_data = sqlite3_column_int64(stmt, 1);
    strncpy(obj->data_type, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->data_type)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithVariable_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_variable (\n"
        "    name TEXT,\n"
        "    var_type TEXT,\n"
        "    initial_value TEXT,\n"
        "    is_const INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithVariable_insert(sqlite3 *db, const SmithVariable *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_variable (name, var_type, initial_value, is_const) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->var_type, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->initial_value, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->is_const);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithVariable_select_by_id(sqlite3 *db, int64_t id, SmithVariable *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_variable WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->var_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->var_type)-1);
    strncpy(obj->initial_value, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->initial_value)-1);
    obj->is_const = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithMachine_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_machine (\n"
        "    name TEXT,\n"
        "    state_count INTEGER,\n"
        "    transition_count INTEGER,\n"
        "    event_count INTEGER,\n"
        "    variable_count INTEGER,\n"
        "    initial_state TEXT,\n"
        "    output_format INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithMachine_insert(sqlite3 *db, const SmithMachine *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_machine (name, state_count, transition_count, event_count, variable_count, initial_state, output_format) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->state_count);
    sqlite3_bind_int64(stmt, 3, obj->transition_count);
    sqlite3_bind_int64(stmt, 4, obj->event_count);
    sqlite3_bind_int64(stmt, 5, obj->variable_count);
    sqlite3_bind_text(stmt, 6, obj->initial_state, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, obj->output_format);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithMachine_select_by_id(sqlite3 *db, int64_t id, SmithMachine *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_machine WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->state_count = sqlite3_column_int64(stmt, 1);
    obj->transition_count = sqlite3_column_int64(stmt, 2);
    obj->event_count = sqlite3_column_int64(stmt, 3);
    obj->variable_count = sqlite3_column_int64(stmt, 4);
    strncpy(obj->initial_state, (const char*)sqlite3_column_text(stmt, 5), sizeof(obj->initial_state)-1);
    obj->output_format = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithRenderConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_render_config (\n"
        "    file_top TEXT,\n"
        "    auto_expand_begin TEXT,\n"
        "    auto_expand_end TEXT,\n"
        "    output_directory TEXT,\n"
        "    output_file_name_no_ext TEXT,\n"
        "    use_partial_class INTEGER,\n"
        "    c_file_extension TEXT,\n"
        "    h_file_extension TEXT,\n"
        "    c_state_enum_typedef INTEGER,\n"
        "    c_event_enum_typedef INTEGER,\n"
        "    c_use_switch_dispatch INTEGER,\n"
        "    c_use_packed_enum INTEGER,\n"
        "    trace_enabled INTEGER,\n"
        "    trace_entry TEXT,\n"
        "    trace_exit TEXT,\n"
        "    trace_transition TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithRenderConfig_insert(sqlite3 *db, const SmithRenderConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_render_config (file_top, auto_expand_begin, auto_expand_end, output_directory, output_file_name_no_ext, use_partial_class, c_file_extension, h_file_extension, c_state_enum_typedef, c_event_enum_typedef, c_use_switch_dispatch, c_use_packed_enum, trace_enabled, trace_entry, trace_exit, trace_transition) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->file_top, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->auto_expand_begin, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->auto_expand_end, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->output_directory, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->output_file_name_no_ext, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->use_partial_class);
    sqlite3_bind_text(stmt, 7, obj->c_file_extension, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 8, obj->h_file_extension, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 9, obj->c_state_enum_typedef);
    sqlite3_bind_int64(stmt, 10, obj->c_event_enum_typedef);
    sqlite3_bind_int64(stmt, 11, obj->c_use_switch_dispatch);
    sqlite3_bind_int64(stmt, 12, obj->c_use_packed_enum);
    sqlite3_bind_int64(stmt, 13, obj->trace_enabled);
    sqlite3_bind_text(stmt, 14, obj->trace_entry, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 15, obj->trace_exit, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 16, obj->trace_transition, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithRenderConfig_select_by_id(sqlite3 *db, int64_t id, SmithRenderConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_render_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->file_top, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->file_top)-1);
    strncpy(obj->auto_expand_begin, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->auto_expand_begin)-1);
    strncpy(obj->auto_expand_end, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->auto_expand_end)-1);
    strncpy(obj->output_directory, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->output_directory)-1);
    strncpy(obj->output_file_name_no_ext, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->output_file_name_no_ext)-1);
    obj->use_partial_class = sqlite3_column_int64(stmt, 5);
    strncpy(obj->c_file_extension, (const char*)sqlite3_column_text(stmt, 6), sizeof(obj->c_file_extension)-1);
    strncpy(obj->h_file_extension, (const char*)sqlite3_column_text(stmt, 7), sizeof(obj->h_file_extension)-1);
    obj->c_state_enum_typedef = sqlite3_column_int64(stmt, 8);
    obj->c_event_enum_typedef = sqlite3_column_int64(stmt, 9);
    obj->c_use_switch_dispatch = sqlite3_column_int64(stmt, 10);
    obj->c_use_packed_enum = sqlite3_column_int64(stmt, 11);
    obj->trace_enabled = sqlite3_column_int64(stmt, 12);
    strncpy(obj->trace_entry, (const char*)sqlite3_column_text(stmt, 13), sizeof(obj->trace_entry)-1);
    strncpy(obj->trace_exit, (const char*)sqlite3_column_text(stmt, 14), sizeof(obj->trace_exit)-1);
    strncpy(obj->trace_transition, (const char*)sqlite3_column_text(stmt, 15), sizeof(obj->trace_transition)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithInputSource_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_input_source (\n"
        "    input_type INTEGER,\n"
        "    file_path TEXT,\n"
        "    page_name TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithInputSource_insert(sqlite3 *db, const SmithInputSource *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_input_source (input_type, file_path, page_name) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->input_type);
    sqlite3_bind_text(stmt, 2, obj->file_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->page_name, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithInputSource_select_by_id(sqlite3 *db, int64_t id, SmithInputSource *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_input_source WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->input_type = sqlite3_column_int64(stmt, 0);
    strncpy(obj->file_path, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->file_path)-1);
    strncpy(obj->page_name, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->page_name)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithProjectConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_project_config (\n"
        "    input_path TEXT,\n"
        "    input_type TEXT,\n"
        "    output_dir TEXT,\n"
        "    output_lang TEXT,\n"
        "    render_config_file TEXT,\n"
        "    validate_only INTEGER,\n"
        "    dump_graph INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithProjectConfig_insert(sqlite3 *db, const SmithProjectConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_project_config (input_path, input_type, output_dir, output_lang, render_config_file, validate_only, dump_graph) VALUES (?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->input_type, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->output_dir, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->output_lang, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->render_config_file, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->validate_only);
    sqlite3_bind_int64(stmt, 7, obj->dump_graph);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithProjectConfig_select_by_id(sqlite3 *db, int64_t id, SmithProjectConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_project_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->input_type, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->input_type)-1);
    strncpy(obj->output_dir, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->output_dir)-1);
    strncpy(obj->output_lang, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->output_lang)-1);
    strncpy(obj->render_config_file, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->render_config_file)-1);
    obj->validate_only = sqlite3_column_int64(stmt, 5);
    obj->dump_graph = sqlite3_column_int64(stmt, 6);
    sqlite3_finalize(stmt);
    return 0;
}

int SmithValidationError_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS smith_validation_error (\n"
        "    error_type INTEGER,\n"
        "    message TEXT,\n"
        "    state_name TEXT,\n"
        "    line_number INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int SmithValidationError_insert(sqlite3 *db, const SmithValidationError *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO smith_validation_error (error_type, message, state_name, line_number) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->error_type);
    sqlite3_bind_text(stmt, 2, obj->message, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->state_name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->line_number);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int SmithValidationError_select_by_id(sqlite3 *db, int64_t id, SmithValidationError *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM smith_validation_error WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->error_type = sqlite3_column_int64(stmt, 0);
    strncpy(obj->message, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->message)-1);
    strncpy(obj->state_name, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->state_name)-1);
    obj->line_number = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

