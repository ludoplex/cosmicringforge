/* AUTO-GENERATED by schemagen 2.0.0 â€” DO NOT EDIT */
/* SQLite bindings */

#include "wasm_sql.h"
#include <string.h>

int WasmOptPass_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wasm_opt_pass (\n"
        "    name TEXT,\n"
        "    enabled INTEGER,\n"
        "    options TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WasmOptPass_insert(sqlite3 *db, const WasmOptPass *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wasm_opt_pass (name, enabled, options) VALUES (?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, obj->enabled);
    sqlite3_bind_text(stmt, 3, obj->options, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WasmOptPass_select_by_id(sqlite3 *db, int64_t id, WasmOptPass *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wasm_opt_pass WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    obj->enabled = sqlite3_column_int64(stmt, 1);
    strncpy(obj->options, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->options)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int BinaryenConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS binaryen_config (\n"
        "    input_path TEXT,\n"
        "    output_path TEXT,\n"
        "    optimize_level INTEGER,\n"
        "    shrink_level INTEGER,\n"
        "    enable_simd INTEGER,\n"
        "    enable_threads INTEGER,\n"
        "    enable_bulk_memory INTEGER,\n"
        "    enable_reference_types INTEGER,\n"
        "    enable_gc INTEGER,\n"
        "    enable_exception_handling INTEGER,\n"
        "    enable_tail_call INTEGER,\n"
        "    low_memory_unused INTEGER,\n"
        "    zero_filled_memory INTEGER,\n"
        "    fast_math INTEGER,\n"
        "    debug_info INTEGER,\n"
        "    source_map INTEGER,\n"
        "    source_map_url TEXT,\n"
        "    emit_text INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int BinaryenConfig_insert(sqlite3 *db, const BinaryenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO binaryen_config (input_path, output_path, optimize_level, shrink_level, enable_simd, enable_threads, enable_bulk_memory, enable_reference_types, enable_gc, enable_exception_handling, enable_tail_call, low_memory_unused, zero_filled_memory, fast_math, debug_info, source_map, source_map_url, emit_text) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_path, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_path, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->optimize_level);
    sqlite3_bind_int64(stmt, 4, obj->shrink_level);
    sqlite3_bind_int64(stmt, 5, obj->enable_simd);
    sqlite3_bind_int64(stmt, 6, obj->enable_threads);
    sqlite3_bind_int64(stmt, 7, obj->enable_bulk_memory);
    sqlite3_bind_int64(stmt, 8, obj->enable_reference_types);
    sqlite3_bind_int64(stmt, 9, obj->enable_gc);
    sqlite3_bind_int64(stmt, 10, obj->enable_exception_handling);
    sqlite3_bind_int64(stmt, 11, obj->enable_tail_call);
    sqlite3_bind_int64(stmt, 12, obj->low_memory_unused);
    sqlite3_bind_int64(stmt, 13, obj->zero_filled_memory);
    sqlite3_bind_int64(stmt, 14, obj->fast_math);
    sqlite3_bind_int64(stmt, 15, obj->debug_info);
    sqlite3_bind_int64(stmt, 16, obj->source_map);
    sqlite3_bind_text(stmt, 17, obj->source_map_url, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 18, obj->emit_text);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int BinaryenConfig_select_by_id(sqlite3 *db, int64_t id, BinaryenConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM binaryen_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_path, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_path)-1);
    strncpy(obj->output_path, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_path)-1);
    obj->optimize_level = sqlite3_column_int64(stmt, 2);
    obj->shrink_level = sqlite3_column_int64(stmt, 3);
    obj->enable_simd = sqlite3_column_int64(stmt, 4);
    obj->enable_threads = sqlite3_column_int64(stmt, 5);
    obj->enable_bulk_memory = sqlite3_column_int64(stmt, 6);
    obj->enable_reference_types = sqlite3_column_int64(stmt, 7);
    obj->enable_gc = sqlite3_column_int64(stmt, 8);
    obj->enable_exception_handling = sqlite3_column_int64(stmt, 9);
    obj->enable_tail_call = sqlite3_column_int64(stmt, 10);
    obj->low_memory_unused = sqlite3_column_int64(stmt, 11);
    obj->zero_filled_memory = sqlite3_column_int64(stmt, 12);
    obj->fast_math = sqlite3_column_int64(stmt, 13);
    obj->debug_info = sqlite3_column_int64(stmt, 14);
    obj->source_map = sqlite3_column_int64(stmt, 15);
    strncpy(obj->source_map_url, (const char*)sqlite3_column_text(stmt, 16), sizeof(obj->source_map_url)-1);
    obj->emit_text = sqlite3_column_int64(stmt, 17);
    sqlite3_finalize(stmt);
    return 0;
}

int WasmOptConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wasm_opt_config (\n"
        "    dce INTEGER,\n"
        "    duplicate_function_elimination INTEGER,\n"
        "    inlining INTEGER,\n"
        "    local_cse INTEGER,\n"
        "    memory_packing INTEGER,\n"
        "    optimize_instructions INTEGER,\n"
        "    precompute INTEGER,\n"
        "    remove_unused_names INTEGER,\n"
        "    reorder_functions INTEGER,\n"
        "    simplify_globals INTEGER,\n"
        "    simplify_locals INTEGER,\n"
        "    vacuum INTEGER,\n"
        "    asyncify INTEGER,\n"
        "    flatten INTEGER,\n"
        "    legalize_js_interface INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WasmOptConfig_insert(sqlite3 *db, const WasmOptConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wasm_opt_config (dce, duplicate_function_elimination, inlining, local_cse, memory_packing, optimize_instructions, precompute, remove_unused_names, reorder_functions, simplify_globals, simplify_locals, vacuum, asyncify, flatten, legalize_js_interface) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->dce);
    sqlite3_bind_int64(stmt, 2, obj->duplicate_function_elimination);
    sqlite3_bind_int64(stmt, 3, obj->inlining);
    sqlite3_bind_int64(stmt, 4, obj->local_cse);
    sqlite3_bind_int64(stmt, 5, obj->memory_packing);
    sqlite3_bind_int64(stmt, 6, obj->optimize_instructions);
    sqlite3_bind_int64(stmt, 7, obj->precompute);
    sqlite3_bind_int64(stmt, 8, obj->remove_unused_names);
    sqlite3_bind_int64(stmt, 9, obj->reorder_functions);
    sqlite3_bind_int64(stmt, 10, obj->simplify_globals);
    sqlite3_bind_int64(stmt, 11, obj->simplify_locals);
    sqlite3_bind_int64(stmt, 12, obj->vacuum);
    sqlite3_bind_int64(stmt, 13, obj->asyncify);
    sqlite3_bind_int64(stmt, 14, obj->flatten);
    sqlite3_bind_int64(stmt, 15, obj->legalize_js_interface);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WasmOptConfig_select_by_id(sqlite3 *db, int64_t id, WasmOptConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wasm_opt_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->dce = sqlite3_column_int64(stmt, 0);
    obj->duplicate_function_elimination = sqlite3_column_int64(stmt, 1);
    obj->inlining = sqlite3_column_int64(stmt, 2);
    obj->local_cse = sqlite3_column_int64(stmt, 3);
    obj->memory_packing = sqlite3_column_int64(stmt, 4);
    obj->optimize_instructions = sqlite3_column_int64(stmt, 5);
    obj->precompute = sqlite3_column_int64(stmt, 6);
    obj->remove_unused_names = sqlite3_column_int64(stmt, 7);
    obj->reorder_functions = sqlite3_column_int64(stmt, 8);
    obj->simplify_globals = sqlite3_column_int64(stmt, 9);
    obj->simplify_locals = sqlite3_column_int64(stmt, 10);
    obj->vacuum = sqlite3_column_int64(stmt, 11);
    obj->asyncify = sqlite3_column_int64(stmt, 12);
    obj->flatten = sqlite3_column_int64(stmt, 13);
    obj->legalize_js_interface = sqlite3_column_int64(stmt, 14);
    sqlite3_finalize(stmt);
    return 0;
}

int WamrModule_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wamr_module (\n"
        "    name TEXT,\n"
        "    wasm_data TEXT,\n"
        "    wasm_size INTEGER,\n"
        "    heap_size INTEGER,\n"
        "    stack_size INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WamrModule_insert(sqlite3 *db, const WamrModule *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wamr_module (name, wasm_data, wasm_size, heap_size, stack_size) VALUES (?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->wasm_data, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 3, obj->wasm_size);
    sqlite3_bind_int64(stmt, 4, obj->heap_size);
    sqlite3_bind_int64(stmt, 5, obj->stack_size);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WamrModule_select_by_id(sqlite3 *db, int64_t id, WamrModule *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wamr_module WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->wasm_data, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->wasm_data)-1);
    obj->wasm_size = sqlite3_column_int64(stmt, 2);
    obj->heap_size = sqlite3_column_int64(stmt, 3);
    obj->stack_size = sqlite3_column_int64(stmt, 4);
    sqlite3_finalize(stmt);
    return 0;
}

int WamrImport_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wamr_import (\n"
        "    module_name TEXT,\n"
        "    func_name TEXT,\n"
        "    signature TEXT,\n"
        "    native_func TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WamrImport_insert(sqlite3 *db, const WamrImport *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wamr_import (module_name, func_name, signature, native_func) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->module_name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->func_name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->signature, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->native_func, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WamrImport_select_by_id(sqlite3 *db, int64_t id, WamrImport *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wamr_import WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->module_name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->module_name)-1);
    strncpy(obj->func_name, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->func_name)-1);
    strncpy(obj->signature, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->signature)-1);
    strncpy(obj->native_func, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->native_func)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int WamrExport_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wamr_export (\n"
        "    name TEXT,\n"
        "    signature TEXT\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WamrExport_insert(sqlite3 *db, const WamrExport *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wamr_export (name, signature) VALUES (?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->signature, -1, SQLITE_STATIC);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WamrExport_select_by_id(sqlite3 *db, int64_t id, WamrExport *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wamr_export WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->name)-1);
    strncpy(obj->signature, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->signature)-1);
    sqlite3_finalize(stmt);
    return 0;
}

int WamrRuntimeConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wamr_runtime_config (\n"
        "    exec_mode INTEGER,\n"
        "    interp_mode INTEGER,\n"
        "    global_heap_size INTEGER,\n"
        "    max_thread_num INTEGER,\n"
        "    enable_bulk_memory INTEGER,\n"
        "    enable_thread_mgr INTEGER,\n"
        "    enable_ref_types INTEGER,\n"
        "    enable_simd INTEGER,\n"
        "    enable_tail_call INTEGER,\n"
        "    enable_memory64 INTEGER,\n"
        "    enable_multi_memory INTEGER,\n"
        "    enable_wasi INTEGER,\n"
        "    wasi_dirs TEXT,\n"
        "    enable_debug INTEGER,\n"
        "    debug_port INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WamrRuntimeConfig_insert(sqlite3 *db, const WamrRuntimeConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wamr_runtime_config (exec_mode, interp_mode, global_heap_size, max_thread_num, enable_bulk_memory, enable_thread_mgr, enable_ref_types, enable_simd, enable_tail_call, enable_memory64, enable_multi_memory, enable_wasi, wasi_dirs, enable_debug, debug_port) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, obj->exec_mode);
    sqlite3_bind_int64(stmt, 2, obj->interp_mode);
    sqlite3_bind_int64(stmt, 3, obj->global_heap_size);
    sqlite3_bind_int64(stmt, 4, obj->max_thread_num);
    sqlite3_bind_int64(stmt, 5, obj->enable_bulk_memory);
    sqlite3_bind_int64(stmt, 6, obj->enable_thread_mgr);
    sqlite3_bind_int64(stmt, 7, obj->enable_ref_types);
    sqlite3_bind_int64(stmt, 8, obj->enable_simd);
    sqlite3_bind_int64(stmt, 9, obj->enable_tail_call);
    sqlite3_bind_int64(stmt, 10, obj->enable_memory64);
    sqlite3_bind_int64(stmt, 11, obj->enable_multi_memory);
    sqlite3_bind_int64(stmt, 12, obj->enable_wasi);
    sqlite3_bind_text(stmt, 13, obj->wasi_dirs, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 14, obj->enable_debug);
    sqlite3_bind_int64(stmt, 15, obj->debug_port);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WamrRuntimeConfig_select_by_id(sqlite3 *db, int64_t id, WamrRuntimeConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wamr_runtime_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    obj->exec_mode = sqlite3_column_int64(stmt, 0);
    obj->interp_mode = sqlite3_column_int64(stmt, 1);
    obj->global_heap_size = sqlite3_column_int64(stmt, 2);
    obj->max_thread_num = sqlite3_column_int64(stmt, 3);
    obj->enable_bulk_memory = sqlite3_column_int64(stmt, 4);
    obj->enable_thread_mgr = sqlite3_column_int64(stmt, 5);
    obj->enable_ref_types = sqlite3_column_int64(stmt, 6);
    obj->enable_simd = sqlite3_column_int64(stmt, 7);
    obj->enable_tail_call = sqlite3_column_int64(stmt, 8);
    obj->enable_memory64 = sqlite3_column_int64(stmt, 9);
    obj->enable_multi_memory = sqlite3_column_int64(stmt, 10);
    obj->enable_wasi = sqlite3_column_int64(stmt, 11);
    strncpy(obj->wasi_dirs, (const char*)sqlite3_column_text(stmt, 12), sizeof(obj->wasi_dirs)-1);
    obj->enable_debug = sqlite3_column_int64(stmt, 13);
    obj->debug_port = sqlite3_column_int64(stmt, 14);
    sqlite3_finalize(stmt);
    return 0;
}

int WamrAotConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wamr_aot_config (\n"
        "    input_wasm TEXT,\n"
        "    output_aot TEXT,\n"
        "    target_arch TEXT,\n"
        "    target_abi TEXT,\n"
        "    cpu TEXT,\n"
        "    opt_level INTEGER,\n"
        "    size_level INTEGER,\n"
        "    enable_simd INTEGER,\n"
        "    enable_bulk_memory INTEGER,\n"
        "    enable_ref_types INTEGER,\n"
        "    bounds_checks INTEGER,\n"
        "    stack_bounds_checks INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WamrAotConfig_insert(sqlite3 *db, const WamrAotConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wamr_aot_config (input_wasm, output_aot, target_arch, target_abi, cpu, opt_level, size_level, enable_simd, enable_bulk_memory, enable_ref_types, bounds_checks, stack_bounds_checks) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->input_wasm, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->output_aot, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->target_arch, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->target_abi, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->cpu, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->opt_level);
    sqlite3_bind_int64(stmt, 7, obj->size_level);
    sqlite3_bind_int64(stmt, 8, obj->enable_simd);
    sqlite3_bind_int64(stmt, 9, obj->enable_bulk_memory);
    sqlite3_bind_int64(stmt, 10, obj->enable_ref_types);
    sqlite3_bind_int64(stmt, 11, obj->bounds_checks);
    sqlite3_bind_int64(stmt, 12, obj->stack_bounds_checks);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WamrAotConfig_select_by_id(sqlite3 *db, int64_t id, WamrAotConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wamr_aot_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->input_wasm, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->input_wasm)-1);
    strncpy(obj->output_aot, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->output_aot)-1);
    strncpy(obj->target_arch, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->target_arch)-1);
    strncpy(obj->target_abi, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->target_abi)-1);
    strncpy(obj->cpu, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->cpu)-1);
    obj->opt_level = sqlite3_column_int64(stmt, 5);
    obj->size_level = sqlite3_column_int64(stmt, 6);
    obj->enable_simd = sqlite3_column_int64(stmt, 7);
    obj->enable_bulk_memory = sqlite3_column_int64(stmt, 8);
    obj->enable_ref_types = sqlite3_column_int64(stmt, 9);
    obj->bounds_checks = sqlite3_column_int64(stmt, 10);
    obj->stack_bounds_checks = sqlite3_column_int64(stmt, 11);
    sqlite3_finalize(stmt);
    return 0;
}

int WasmEmbedding_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wasm_embedding (\n"
        "    module_name TEXT,\n"
        "    wasm_file TEXT,\n"
        "    c_symbol TEXT,\n"
        "    compress INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WasmEmbedding_insert(sqlite3 *db, const WasmEmbedding *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wasm_embedding (module_name, wasm_file, c_symbol, compress) VALUES (?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->module_name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->wasm_file, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->c_symbol, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 4, obj->compress);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WasmEmbedding_select_by_id(sqlite3 *db, int64_t id, WasmEmbedding *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wasm_embedding WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->module_name, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->module_name)-1);
    strncpy(obj->wasm_file, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->wasm_file)-1);
    strncpy(obj->c_symbol, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->c_symbol)-1);
    obj->compress = sqlite3_column_int64(stmt, 3);
    sqlite3_finalize(stmt);
    return 0;
}

int WasmBuildConfig_create_table(sqlite3 *db) {
    const char *sql = "CREATE TABLE IF NOT EXISTS wasm_build_config (\n"
        "    source_files TEXT,\n"
        "    include_dirs TEXT,\n"
        "    defines TEXT,\n"
        "    clang_target TEXT,\n"
        "    optimization TEXT,\n"
        "    link_wasi INTEGER,\n"
        "    export_all INTEGER,\n"
        "    stack_size INTEGER,\n"
        "    initial_memory INTEGER,\n"
        "    max_memory INTEGER,\n"
        "    run_wasm_opt INTEGER,\n"
        "    wasm_opt_level INTEGER,\n"
        "    output_wasm TEXT,\n"
        "    output_wat INTEGER,\n"
        "    embed_in_c INTEGER\n"
        ")";
    return sqlite3_exec(db, sql, NULL, NULL, NULL);
}

int WasmBuildConfig_insert(sqlite3 *db, const WasmBuildConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO wasm_build_config (source_files, include_dirs, defines, clang_target, optimization, link_wasi, export_all, stack_size, initial_memory, max_memory, run_wasm_opt, wasm_opt_level, output_wasm, output_wat, embed_in_c) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_text(stmt, 1, obj->source_files, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, obj->include_dirs, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, obj->defines, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, obj->clang_target, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, obj->optimization, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 6, obj->link_wasi);
    sqlite3_bind_int64(stmt, 7, obj->export_all);
    sqlite3_bind_int64(stmt, 8, obj->stack_size);
    sqlite3_bind_int64(stmt, 9, obj->initial_memory);
    sqlite3_bind_int64(stmt, 10, obj->max_memory);
    sqlite3_bind_int64(stmt, 11, obj->run_wasm_opt);
    sqlite3_bind_int64(stmt, 12, obj->wasm_opt_level);
    sqlite3_bind_text(stmt, 13, obj->output_wasm, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 14, obj->output_wat);
    sqlite3_bind_int64(stmt, 15, obj->embed_in_c);
    int rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE ? 0 : -1;
}

int WasmBuildConfig_select_by_id(sqlite3 *db, int64_t id, WasmBuildConfig *obj) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM wasm_build_config WHERE id = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    sqlite3_bind_int64(stmt, 1, id);
    if (sqlite3_step(stmt) != SQLITE_ROW) { sqlite3_finalize(stmt); return -1; }
    strncpy(obj->source_files, (const char*)sqlite3_column_text(stmt, 0), sizeof(obj->source_files)-1);
    strncpy(obj->include_dirs, (const char*)sqlite3_column_text(stmt, 1), sizeof(obj->include_dirs)-1);
    strncpy(obj->defines, (const char*)sqlite3_column_text(stmt, 2), sizeof(obj->defines)-1);
    strncpy(obj->clang_target, (const char*)sqlite3_column_text(stmt, 3), sizeof(obj->clang_target)-1);
    strncpy(obj->optimization, (const char*)sqlite3_column_text(stmt, 4), sizeof(obj->optimization)-1);
    obj->link_wasi = sqlite3_column_int64(stmt, 5);
    obj->export_all = sqlite3_column_int64(stmt, 6);
    obj->stack_size = sqlite3_column_int64(stmt, 7);
    obj->initial_memory = sqlite3_column_int64(stmt, 8);
    obj->max_memory = sqlite3_column_int64(stmt, 9);
    obj->run_wasm_opt = sqlite3_column_int64(stmt, 10);
    obj->wasm_opt_level = sqlite3_column_int64(stmt, 11);
    strncpy(obj->output_wasm, (const char*)sqlite3_column_text(stmt, 12), sizeof(obj->output_wasm)-1);
    obj->output_wat = sqlite3_column_int64(stmt, 13);
    obj->embed_in_c = sqlite3_column_int64(stmt, 14);
    sqlite3_finalize(stmt);
    return 0;
}

