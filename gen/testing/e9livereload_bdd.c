/* AUTO-GENERATED by bddgen 1.0.0 — DO NOT EDIT */

#include "e9livereload_bdd.h"
#include <stdio.h>
#include <string.h>

/* Feature data */
static const char *feature_0_name = "E9 Live Reload - Hot Patching APE Binaries";

/* Scenario data */
typedef struct {
    const char *name;
    int step_start;
    int step_count;
    int feature_index;
} scenario_info_t;

static const scenario_info_t scenarios[] = {
    {"Detect C source file changes", 0, 4, 0},
    {"Ignore non-C files", 4, 3, 0},
    {"Successful incremental compilation", 7, 6, 0},
    {"Compilation failure handling", 13, 5, 0},
    {"Generate patches from object diff", 18, 6, 0},
    {"No patches when no functional changes", 24, 5, 0},
    {"Apply patch via PE RVA", 29, 6, 0},
    {"Apply patch to .rdata section", 35, 5, 0},
    {"Reject patch overlapping ZipOS", 40, 5, 0},
    {"Flush icache after code patch", 45, 4, 0},
    {"Self-patching the running executable", 49, 5, 0},
    {"Track live reload statistics", 54, 3, 0},
    {"Revert a previously applied patch", 57, 6, 0},
    {"Handle missing compiler gracefully", 63, 4, 0},
    {"Handle unmappable target", 67, 4, 0},
};
static const int scenario_count = 15;

/* Step data */
typedef struct {
    const char *text;
    int keyword;  /* 0=Given, 1=When, 2=Then */
    int line_number;
    E9LIVERELOAD_step_fn function;
} step_info_t;

static const step_info_t steps[] = {
    {"an APE binary \"target.com\" is loaded", 0, 7, step_an_ape_binary_targetcom_is_loaded},
    {"live reload is initialized with source directory \"src/\"", 0, 8, step_live_reload_is_initialized_with_source_directory_src},
    {"the compiler \"cosmocc\" is available", 0, 9, step_the_compiler_cosmocc_is_available},
    {"a source file \"src/main.c\" exists", 0, 14, step_a_source_file_srcmainc_exists},
    {"I modify \"src/main.c\"", 1, 15, step_i_modify_srcmainc},
    {"a FILE_CHANGE event should be emitted", 2, 16, step_a_file_change_event_should_be_emitted},
    {"the event should contain the file path \"src/main.c\"", 2, 17, step_the_event_should_contain_the_file_path_srcmainc},
    {"a source file \"src/README.md\" exists", 0, 20, step_a_source_file_srcreadmemd_exists},
    {"I modify \"src/README.md\"", 1, 21, step_i_modify_srcreadmemd},
    {"no FILE_CHANGE event should be emitted", 2, 22, step_no_file_change_event_should_be_emitted},
    {"a valid C source file \"src/func.c\"", 0, 27, step_a_valid_c_source_file_srcfuncc},
    {"a FILE_CHANGE event is detected for \"src/func.c\"", 1, 28, step_a_file_change_event_is_detected_for_srcfuncc},
    {"a COMPILE_START event should be emitted", 2, 29, step_a_compile_start_event_should_be_emitted},
    {"cosmocc should be invoked with \"-c src/func.c\"", 2, 30, step_cosmocc_should_be_invoked_with_c_srcfuncc},
    {"a COMPILE_DONE event should be emitted", 2, 31, step_a_compile_done_event_should_be_emitted},
    {"the object file should be cached in \".e9cache/\"", 2, 32, step_the_object_file_should_be_cached_in_e9cache},
    {"an invalid C source file \"src/broken.c\" with syntax errors", 0, 35, step_an_invalid_c_source_file_srcbrokenc_with_syntax_errors},
    {"a FILE_CHANGE event is detected for \"src/broken.c\"", 1, 36, step_a_file_change_event_is_detected_for_srcbrokenc},
    {"a COMPILE_ERROR event should be emitted", 2, 37, step_a_compile_error_event_should_be_emitted},
    {"the error message should contain the compiler output", 2, 38, step_the_error_message_should_contain_the_compiler_output},
    {"no patches should be generated", 2, 39, step_no_patches_should_be_generated},
    {"a cached object \"func.c.o\" from previous compilation", 0, 44, step_a_cached_object_funcco_from_previous_compilation},
    {"a new object \"func.c.new.o\" with changes to function \"process_data\"", 0, 45, step_a_new_object_funccnewo_with_changes_to_function_process_data},
    {"Binaryen diffs the two objects", 1, 46, step_binaryen_diffs_the_two_objects},
    {"a PATCH_GENERATED event should be emitted", 2, 47, step_a_patch_generated_event_should_be_emitted},
    {"the patch should target function \"process_data\"", 2, 48, step_the_patch_should_target_function_process_data},
    {"the patch should contain the address and replacement bytes", 2, 49, step_the_patch_should_contain_the_address_and_replacement_bytes},
    {"a cached object \"func.c.o\"", 0, 52, step_a_cached_object_funcco},
    {"a new object \"func.c.new.o\" with only whitespace changes", 0, 53, step_a_new_object_funccnewo_with_only_whitespace_changes},
    {"Binaryen diffs the two objects", 1, 54, step_binaryen_diffs_the_two_objects},
    {"no PATCH_GENERATED event should be emitted", 2, 55, step_no_patch_generated_event_should_be_emitted},
    {"the status should indicate \"No changes detected\"", 2, 56, step_the_status_should_indicate_no_changes_detected},
    {"a patch targeting PE RVA 0x11234", 0, 61, step_a_patch_targeting_pe_rva_0x11234},
    {"the APE has .text section at file offset 0x11000 with RVA 0x11000", 0, 62, step_the_ape_has_text_section_at_file_offset_0x11000_with_rva_0x11000},
    {"the patch is applied", 1, 63, step_the_patch_is_applied},
    {"the file offset should be calculated as 0x11234", 2, 64, step_the_file_offset_should_be_calculated_as_0x11234},
    {"the bytes should be written to the memory-mapped binary", 2, 65, step_the_bytes_should_be_written_to_the_memory_mapped_binary},
    {"a PATCH_APPLIED event should be emitted", 2, 66, step_a_patch_applied_event_should_be_emitted},
    {"a patch targeting PE RVA 0x2F100", 0, 69, step_a_patch_targeting_pe_rva_0x2f100},
    {"the APE has .rdata section at file offset 0x2F000 with RVA 0x2F000", 0, 70, step_the_ape_has_rdata_section_at_file_offset_0x2f000_with_rva_0x2f000},
    {"the patch is applied", 1, 71, step_the_patch_is_applied},
    {"the file offset should be calculated as 0x2F100", 2, 72, step_the_file_offset_should_be_calculated_as_0x2f100},
    {"the patch should succeed", 2, 73, step_the_patch_should_succeed},
    {"an APE with ZipOS starting at offset 0x60000", 0, 76, step_an_ape_with_zipos_starting_at_offset_0x60000},
    {"a patch targeting file offset 0x60010", 0, 77, step_a_patch_targeting_file_offset_0x60010},
    {"the patch is applied", 1, 78, step_the_patch_is_applied},
    {"a warning should be emitted about ZipOS overlap", 2, 79, step_a_warning_should_be_emitted_about_zipos_overlap},
    {"the patch may proceed with user acknowledgment", 2, 80, step_the_patch_may_proceed_with_user_acknowledgment},
    {"a patch was applied to executable .text section", 0, 85, step_a_patch_was_applied_to_executable_text_section},
    {"the patch is finalized", 1, 86, step_the_patch_is_finalized},
    {"e9wasm_flush_icache should be called", 2, 87, step_e9wasm_flush_icache_should_be_called},
    {"the flushed range should cover the patched bytes", 2, 88, step_the_flushed_range_should_cover_the_patched_bytes},
    {"live reload is initialized with target NULL (self)", 0, 93, step_live_reload_is_initialized_with_target_null_self},
    {"the executable path is determined via /proc/self/exe", 1, 94, step_the_executable_path_is_determined_via_procselfexe},
    {"the running APE should be memory-mapped", 2, 95, step_the_running_ape_should_be_memory_mapped},
    {"patches should be applied in-place", 2, 96, step_patches_should_be_applied_in_place},
    {"execution should continue with the new code", 2, 97, step_execution_should_continue_with_the_new_code},
    {"live reload has processed multiple source changes", 0, 102, step_live_reload_has_processed_multiple_source_changes},
    {"I query the statistics", 1, 103, step_i_query_the_statistics},
    {"I should see:", 2, 104, step_i_should_see},
    {"patch #1 was applied at offset 0x11234", 0, 117, step_patch_1_was_applied_at_offset_0x11234},
    {"the original bytes were saved", 0, 118, step_the_original_bytes_were_saved},
    {"I revert patch #1", 1, 119, step_i_revert_patch_1},
    {"the original bytes should be restored", 2, 120, step_the_original_bytes_should_be_restored},
    {"a PATCH_REVERTED event should be emitted", 2, 121, step_a_patch_reverted_event_should_be_emitted},
    {"the instruction cache should be flushed", 2, 122, step_the_instruction_cache_should_be_flushed},
    {"the compiler \"cosmocc\" is not in PATH", 0, 127, step_the_compiler_cosmocc_is_not_in_path},
    {"I call e9_livereload_compiler_available()", 1, 128, step_i_call_e9_livereload_compiler_available},
    {"it should return false", 2, 129, step_it_should_return_false},
    {"compilation attempts should fail with a clear error message", 2, 130, step_compilation_attempts_should_fail_with_a_clear_error_message},
    {"a target file that does not exist", 0, 133, step_a_target_file_that_does_not_exist},
    {"I initialize live reload with that target", 1, 134, step_i_initialize_live_reload_with_that_target},
    {"initialization should fail with error \"Cannot open target\"", 2, 135, step_initialization_should_fail_with_error_cannot_open_target},
    {"e9_livereload_get_error() should return the error message", 2, 136, step_e9_livereload_get_error_should_return_the_error_message},
};
static const int total_steps = 74;

static const char *result_names[] = {
    "PASS", "FAIL", "SKIP", "PENDING", "ERROR"
};

void E9LIVERELOAD_run_scenario(void *world, int scenario_index, E9LIVERELOAD_stats_t *stats) {
    if (scenario_index < 0 || scenario_index >= scenario_count) return;

    const scenario_info_t *sc = &scenarios[scenario_index];
    const char *feature_name = "";
    if (sc->feature_index == 0) feature_name = feature_0_name;

    printf("  Scenario: %s\n", sc->name);

    E9LIVERELOAD_context_t ctx;
    ctx.world = world;
    ctx.scenario = sc->name;
    ctx.feature = feature_name;

    int scenario_passed = 1;
    for (int i = 0; i < sc->step_count; i++) {
        int step_idx = sc->step_start + i;
        if (step_idx >= total_steps) break;

        const step_info_t *st = &steps[step_idx];
        ctx.step_text = st->text;
        ctx.step_line = st->line_number;

        const char *keyword = (st->keyword == 0) ? "Given" :
                              (st->keyword == 1) ? "When" : "Then";
        printf("    %s %s... ", keyword, st->text);

        E9LIVERELOAD_result_t result = E9LIVERELOAD_PENDING;
        if (st->function) {
            result = st->function(&ctx);
        }

        printf("%s\n", result_names[result]);
        stats->total_steps++;

        if (result == E9LIVERELOAD_PASS) {
            stats->passed_steps++;
        } else {
            stats->failed_steps++;
            scenario_passed = 0;
        }
    }

    stats->total_scenarios++;
    if (scenario_passed) {
        stats->passed_scenarios++;
    } else {
        stats->failed_scenarios++;
    }
}

void E9LIVERELOAD_run_all(void *world, E9LIVERELOAD_stats_t *stats) {
    memset(stats, 0, sizeof(*stats));

    printf("Feature: %s\n\n", feature_0_name);

    for (int i = 0; i < scenario_count; i++) {
        E9LIVERELOAD_run_scenario(world, i, stats);
        printf("\n");
    }
}

void E9LIVERELOAD_print_stats(const E9LIVERELOAD_stats_t *stats) {
    printf("\n═══════════════════════════════════════════════════════════\n");
    printf("BDD Test Results:\n");
    printf("  Scenarios: %d total, %d passed, %d failed, %d skipped\n",
           stats->total_scenarios, stats->passed_scenarios,
           stats->failed_scenarios, stats->skipped_scenarios);
    printf("  Steps:     %d total, %d passed, %d failed\n",
           stats->total_steps, stats->passed_steps, stats->failed_steps);
    printf("═══════════════════════════════════════════════════════════\n");
}
