/* AUTO-GENERATED by bddgen 1.0.0 — DO NOT EDIT */
/* Feature: E9 Live Reload - Hot Patching APE Binaries */

#include "e9livereload_bdd.h"
#include <stdio.h>

/* Scenario: Detect C source file changes (line 13) */
int scenario_detect_c_source_file_changes(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_source_file_src_main_c_exists(); /* a source file "src/main.c" exists */
    result |= step_when_i_modify_src_main_c(); /* I modify "src/main.c" */
    result |= step_then_a_file_change_event_should_be_emitted(); /* a FILE_CHANGE event should be emitted */
    result |= step_and_the_event_should_contain_the_file_path_src_main_c(); /* the event should contain the file path "src/main.c" */
    return result;
}

/* Scenario: Ignore non-C files (line 19) */
int scenario_ignore_non_c_files(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_source_file_src_readme_md_exists(); /* a source file "src/README.md" exists */
    result |= step_when_i_modify_src_readme_md(); /* I modify "src/README.md" */
    result |= step_then_no_file_change_event_should_be_emitted(); /* no FILE_CHANGE event should be emitted */
    return result;
}

/* Scenario: Successful incremental compilation (line 26) */
int scenario_successful_incremental_compilation(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_valid_c_source_file_src_func_c(); /* a valid C source file "src/func.c" */
    result |= step_when_a_file_change_event_is_detected_for_src_func_c(); /* a FILE_CHANGE event is detected for "src/func.c" */
    result |= step_then_a_compile_start_event_should_be_emitted(); /* a COMPILE_START event should be emitted */
    result |= step_and_cosmocc_should_be_invoked_with_c_src_func_c(); /* cosmocc should be invoked with "-c src/func.c" */
    result |= step_and_a_compile_done_event_should_be_emitted(); /* a COMPILE_DONE event should be emitted */
    result |= step_and_the_object_file_should_be_cached_in_e9cache(); /* the object file should be cached in ".e9cache/" */
    return result;
}

/* Scenario: Compilation failure handling (line 34) */
int scenario_compilation_failure_handling(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_an_invalid_c_source_file_src_broken_c_with_syntax_errors(); /* an invalid C source file "src/broken.c" with syntax errors */
    result |= step_when_a_file_change_event_is_detected_for_src_broken_c(); /* a FILE_CHANGE event is detected for "src/broken.c" */
    result |= step_then_a_compile_error_event_should_be_emitted(); /* a COMPILE_ERROR event should be emitted */
    result |= step_and_the_error_message_should_contain_the_compiler_output(); /* the error message should contain the compiler output */
    result |= step_and_no_patches_should_be_generated(); /* no patches should be generated */
    return result;
}

/* Scenario: Generate patches from object diff (line 43) */
int scenario_generate_patches_from_object_diff(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_cached_object_func_c_o_from_previous_compilation(); /* a cached object "func.c.o" from previous compilation */
    result |= step_and_a_new_object_func_c_new_o_with_changes_to_function_process_data(); /* a new object "func.c.new.o" with changes to function "process_data" */
    result |= step_when_binaryen_diffs_the_two_objects(); /* Binaryen diffs the two objects */
    result |= step_then_a_patch_generated_event_should_be_emitted(); /* a PATCH_GENERATED event should be emitted */
    result |= step_and_the_patch_should_target_function_process_data(); /* the patch should target function "process_data" */
    result |= step_and_the_patch_should_contain_the_address_and_replacement_bytes(); /* the patch should contain the address and replacement bytes */
    return result;
}

/* Scenario: No patches when no functional changes (line 51) */
int scenario_no_patches_when_no_functional_changes(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_cached_object_func_c_o(); /* a cached object "func.c.o" */
    result |= step_and_a_new_object_func_c_new_o_with_only_whitespace_changes(); /* a new object "func.c.new.o" with only whitespace changes */
    result |= step_when_binaryen_diffs_the_two_objects(); /* Binaryen diffs the two objects */
    result |= step_then_no_patch_generated_event_should_be_emitted(); /* no PATCH_GENERATED event should be emitted */
    result |= step_and_the_status_should_indicate_no_changes_detected(); /* the status should indicate "No changes detected" */
    return result;
}

/* Scenario: Apply patch via PE RVA (line 60) */
int scenario_apply_patch_via_pe_rva(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_patch_targeting_pe_rva_0x11234(); /* a patch targeting PE RVA 0x11234 */
    result |= step_and_the_ape_has_text_section_at_file_offset_0x11000_with_rva_0x11000(); /* the APE has .text section at file offset 0x11000 with RVA 0x11000 */
    result |= step_when_the_patch_is_applied(); /* the patch is applied */
    result |= step_then_the_file_offset_should_be_calculated_as_0x11234(); /* the file offset should be calculated as 0x11234 */
    result |= step_and_the_bytes_should_be_written_to_the_memory_mapped_binary(); /* the bytes should be written to the memory-mapped binary */
    result |= step_and_a_patch_applied_event_should_be_emitted(); /* a PATCH_APPLIED event should be emitted */
    return result;
}

/* Scenario: Apply patch to .rdata section (line 68) */
int scenario_apply_patch_to_rdata_section(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_patch_targeting_pe_rva_0x2f100(); /* a patch targeting PE RVA 0x2F100 */
    result |= step_and_the_ape_has_rdata_section_at_file_offset_0x2f000_with_rva_0x2f00(); /* the APE has .rdata section at file offset 0x2F000 with RVA 0x2F000 */
    result |= step_when_the_patch_is_applied(); /* the patch is applied */
    result |= step_then_the_file_offset_should_be_calculated_as_0x2f100(); /* the file offset should be calculated as 0x2F100 */
    result |= step_and_the_patch_should_succeed(); /* the patch should succeed */
    return result;
}

/* Scenario: Reject patch overlapping ZipOS (line 75) */
int scenario_reject_patch_overlapping_zipos(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_an_ape_with_zipos_starting_at_offset_0x60000(); /* an APE with ZipOS starting at offset 0x60000 */
    result |= step_and_a_patch_targeting_file_offset_0x60010(); /* a patch targeting file offset 0x60010 */
    result |= step_when_the_patch_is_applied(); /* the patch is applied */
    result |= step_then_a_warning_should_be_emitted_about_zipos_overlap(); /* a warning should be emitted about ZipOS overlap */
    result |= step_and_the_patch_may_proceed_with_user_acknowledgment(); /* the patch may proceed with user acknowledgment */
    return result;
}

/* Scenario: Flush icache after code patch (line 84) */
int scenario_flush_icache_after_code_patch(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_patch_was_applied_to_executable_text_section(); /* a patch was applied to executable .text section */
    result |= step_when_the_patch_is_finalized(); /* the patch is finalized */
    result |= step_then_e9wasm_flush_icache_should_be_called(); /* e9wasm_flush_icache should be called */
    result |= step_and_the_flushed_range_should_cover_the_patched_bytes(); /* the flushed range should cover the patched bytes */
    return result;
}

/* Scenario: Self-patching the running executable (line 92) */
int scenario_self_patching_the_running_executable(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_live_reload_is_initialized_with_target_null_self(); /* live reload is initialized with target NULL (self) */
    result |= step_when_the_executable_path_is_determined_via_proc_self_exe(); /* the executable path is determined via /proc/self/exe */
    result |= step_then_the_running_ape_should_be_memory_mapped(); /* the running APE should be memory-mapped */
    result |= step_and_patches_should_be_applied_in_place(); /* patches should be applied in-place */
    result |= step_and_execution_should_continue_with_the_new_code(); /* execution should continue with the new code */
    return result;
}

/* Scenario: Track live reload statistics (line 101) */
int scenario_track_live_reload_statistics(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_live_reload_has_processed_multiple_source_changes(); /* live reload has processed multiple source changes */
    result |= step_when_i_query_the_statistics(); /* I query the statistics */
    result |= step_then_i_should_see(); /* I should see: */
    return result;
}

/* Scenario: Revert a previously applied patch (line 116) */
int scenario_revert_a_previously_applied_patch(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_patch_1_was_applied_at_offset_0x11234(); /* patch #1 was applied at offset 0x11234 */
    result |= step_and_the_original_bytes_were_saved(); /* the original bytes were saved */
    result |= step_when_i_revert_patch_1(); /* I revert patch #1 */
    result |= step_then_the_original_bytes_should_be_restored(); /* the original bytes should be restored */
    result |= step_and_a_patch_reverted_event_should_be_emitted(); /* a PATCH_REVERTED event should be emitted */
    result |= step_and_the_instruction_cache_should_be_flushed(); /* the instruction cache should be flushed */
    return result;
}

/* Scenario: Handle missing compiler gracefully (line 126) */
int scenario_handle_missing_compiler_gracefully(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_the_compiler_cosmocc_is_not_in_path(); /* the compiler "cosmocc" is not in PATH */
    result |= step_when_i_call_e9_livereload_compiler_available(); /* I call e9_livereload_compiler_available() */
    result |= step_then_it_should_return_false(); /* it should return false */
    result |= step_and_compilation_attempts_should_fail_with_a_clear_error_message(); /* compilation attempts should fail with a clear error message */
    return result;
}

/* Scenario: Handle unmappable target (line 132) */
int scenario_handle_unmappable_target(void) {
    int result = 0;
    /* Background */
    result |= step_given_an_ape_binary_target_com_is_loaded(); /* an APE binary "target.com" is loaded */
    result |= step_and_live_reload_is_initialized_with_source_directory_src(); /* live reload is initialized with source directory "src/" */
    result |= step_and_the_compiler_cosmocc_is_available(); /* the compiler "cosmocc" is available */
    /* Steps */
    result |= step_given_a_target_file_that_does_not_exist(); /* a target file that does not exist */
    result |= step_when_i_initialize_live_reload_with_that_target(); /* I initialize live reload with that target */
    result |= step_then_initialization_should_fail_with_error_cannot_open_target(); /* initialization should fail with error "Cannot open target" */
    result |= step_and_e9_livereload_get_error_should_return_the_error_message(); /* e9_livereload_get_error() should return the error message */
    return result;
}

/* Feature runner: E9 Live Reload - Hot Patching APE Binaries */
int feature_e9_live_reload_hot_patching_ape_binaries(void) {
    int pass = 0, fail = 0;
    if (scenario_detect_c_source_file_changes() == 0) pass++; else fail++;
    if (scenario_ignore_non_c_files() == 0) pass++; else fail++;
    if (scenario_successful_incremental_compilation() == 0) pass++; else fail++;
    if (scenario_compilation_failure_handling() == 0) pass++; else fail++;
    if (scenario_generate_patches_from_object_diff() == 0) pass++; else fail++;
    if (scenario_no_patches_when_no_functional_changes() == 0) pass++; else fail++;
    if (scenario_apply_patch_via_pe_rva() == 0) pass++; else fail++;
    if (scenario_apply_patch_to_rdata_section() == 0) pass++; else fail++;
    if (scenario_reject_patch_overlapping_zipos() == 0) pass++; else fail++;
    if (scenario_flush_icache_after_code_patch() == 0) pass++; else fail++;
    if (scenario_self_patching_the_running_executable() == 0) pass++; else fail++;
    if (scenario_track_live_reload_statistics() == 0) pass++; else fail++;
    if (scenario_revert_a_previously_applied_patch() == 0) pass++; else fail++;
    if (scenario_handle_missing_compiler_gracefully() == 0) pass++; else fail++;
    if (scenario_handle_unmappable_target() == 0) pass++; else fail++;
    fprintf(stdout, "Feature: %s — %d passed, %d failed\n",
            "E9 Live Reload - Hot Patching APE Binaries", pass, fail);
    return (fail == 0) ? 0 : 1;
}
