/* AUTO-GENERATED by smgen 1.0.0 â€” DO NOT EDIT */

#include "example_sm.h"
#include <stddef.h>

static const char *state_names[] = {
    "Idle",
    "Configuring",
    "Running",
    "Paused",
    "Failed",
};

static const char *event_names[] = {
    "Start",
    "Config",
    "Done",
    "Apply",
    "Stop",
    "Pause",
    "Error",
    "Resume",
    "Reset",
};

const char *EXAMPLE_state_name(EXAMPLE_state_t state) {
    if (state >= 0 && state < EXAMPLE_STATE_COUNT) return state_names[state];
    return "UNKNOWN";
}

const char *EXAMPLE_event_name(EXAMPLE_event_t event) {
    if (event >= 0 && event < EXAMPLE_EVENT_COUNT) return event_names[event];
    return "UNKNOWN";
}

void EXAMPLE_init(EXAMPLE_context_t *ctx, void *user_data) {
    ctx->current_state = EXAMPLE_STATE_IDLE;
    ctx->user_data = user_data;
    led_off(ctx); /* Entry action */
}

bool EXAMPLE_dispatch(EXAMPLE_context_t *ctx, EXAMPLE_event_t event) {
    switch (ctx->current_state) {
    case EXAMPLE_STATE_IDLE:
        switch (event) {
        case EXAMPLE_EVENT_START:
            ctx->current_state = EXAMPLE_STATE_RUNNING;
            motor_start(ctx); /* Entry */
            return true;
        case EXAMPLE_EVENT_CONFIG:
            ctx->current_state = EXAMPLE_STATE_CONFIGURING;
            show_config_ui(ctx); /* Entry */
            return true;
        default: break;
        }
        break;
    case EXAMPLE_STATE_CONFIGURING:
        switch (event) {
        case EXAMPLE_EVENT_DONE:
            hide_config_ui(ctx); /* Exit */
            ctx->current_state = EXAMPLE_STATE_IDLE;
            led_off(ctx); /* Entry */
            return true;
        case EXAMPLE_EVENT_APPLY:
            hide_config_ui(ctx); /* Exit */
            ctx->current_state = EXAMPLE_STATE_RUNNING;
            motor_start(ctx); /* Entry */
            return true;
        default: break;
        }
        break;
    case EXAMPLE_STATE_RUNNING:
        switch (event) {
        case EXAMPLE_EVENT_STOP:
            motor_stop(ctx); /* Exit */
            ctx->current_state = EXAMPLE_STATE_IDLE;
            led_off(ctx); /* Entry */
            return true;
        case EXAMPLE_EVENT_PAUSE:
            motor_stop(ctx); /* Exit */
            ctx->current_state = EXAMPLE_STATE_PAUSED;
            led_blink(ctx); /* Entry */
            return true;
        case EXAMPLE_EVENT_ERROR:
            motor_stop(ctx); /* Exit */
            ctx->current_state = EXAMPLE_STATE_FAILED;
            alarm_on(ctx); /* Entry */
            return true;
        default: break;
        }
        break;
    case EXAMPLE_STATE_PAUSED:
        switch (event) {
        case EXAMPLE_EVENT_RESUME:
            ctx->current_state = EXAMPLE_STATE_RUNNING;
            motor_start(ctx); /* Entry */
            return true;
        case EXAMPLE_EVENT_STOP:
            ctx->current_state = EXAMPLE_STATE_IDLE;
            led_off(ctx); /* Entry */
            return true;
        default: break;
        }
        break;
    case EXAMPLE_STATE_FAILED:
        switch (event) {
        case EXAMPLE_EVENT_RESET:
            alarm_off(ctx); /* Exit */
            ctx->current_state = EXAMPLE_STATE_IDLE;
            led_off(ctx); /* Entry */
            return true;
        default: break;
        }
        break;
    default: break;
    }
    return false;
}
