/* cosmo-bde — Function Signature Generator
 * Ring 0: Pure C, minimal bootstrap
 *
 * Generates C function declarations from .sig specs.
 * Useful for FFI bindings and header generation.
 *
 * Usage: siggen <input.sig> [output_dir] [prefix]
 *
 * Input:
 *   module math {
 *       fn add(a: i32, b: i32) -> i32
 *       fn multiply(a: f64, b: f64) -> f64 [pure]
 *   }
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <errno.h>
#include <sys/stat.h>

#include "siggen_self.h"

#define SIGGEN_VERSION "1.0.0"
#define MAX_PATH 512
#define MAX_NAME 64
#define MAX_LINE 1024
#define MAX_PARAMS 16
#define MAX_FUNCS 128

typedef struct { char name[MAX_NAME]; char type[MAX_NAME]; } param_t;

typedef struct {
    char name[MAX_NAME];
    param_t params[MAX_PARAMS];
    int param_count;
    char return_type[MAX_NAME];
    int is_pure;
    int is_extern;
} func_t;

typedef struct {
    char name[MAX_NAME];
    func_t funcs[MAX_FUNCS];
    int func_count;
} module_t;

static module_t mod;

static void trim(char *s) {
    while (*s && isspace((unsigned char)*s)) memmove(s, s+1, strlen(s));
    char *e = s + strlen(s) - 1;
    while (e > s && isspace((unsigned char)*e)) *e-- = '\0';
}

static void to_upper(char *s) { for (; *s; s++) *s = toupper((unsigned char)*s); }

static const char *sig_to_c(const char *t) {
    if (strcmp(t, "i32") == 0) return "int32_t";
    if (strcmp(t, "i64") == 0) return "int64_t";
    if (strcmp(t, "u32") == 0) return "uint32_t";
    if (strcmp(t, "u64") == 0) return "uint64_t";
    if (strcmp(t, "f32") == 0) return "float";
    if (strcmp(t, "f64") == 0) return "double";
    if (strcmp(t, "usize") == 0) return "size_t";
    if (strcmp(t, "void") == 0) return "void";
    if (t[0] == '*') return t; /* pointer */
    return t;
}

static int parse_sig(const char *filename) {
    FILE *f = fopen(filename, "r");
    if (!f) { fprintf(stderr, "Error: Cannot open %s\n", filename); return -1; }

    char line[MAX_LINE];
    int in_module = 0;
    memset(&mod, 0, sizeof(mod));

    while (fgets(line, sizeof(line), f)) {
        trim(line);
        if (line[0] == '#' || line[0] == '\0') continue;

        if (strncmp(line, "module ", 7) == 0) {
            char *n = line + 7;
            char *b = strchr(n, '{');
            if (b) *b = '\0';
            trim(n);
            strncpy(mod.name, n, MAX_NAME - 1);
            in_module = 1;
            continue;
        }

        if (line[0] == '}') { in_module = 0; continue; }

        if (in_module && strncmp(line, "fn ", 3) == 0) {
            func_t *fn = &mod.funcs[mod.func_count++];
            memset(fn, 0, sizeof(*fn));

            char *p = line + 3;
            char *lp = strchr(p, '(');
            if (lp) {
                *lp = '\0';
                trim(p);
                strncpy(fn->name, p, MAX_NAME - 1);

                char *rp = strchr(lp + 1, ')');
                if (rp) {
                    *rp = '\0';
                    char *params = lp + 1;
                    char *tok = strtok(params, ",");
                    while (tok && fn->param_count < MAX_PARAMS) {
                        trim(tok);
                        char *colon = strchr(tok, ':');
                        if (colon) {
                            *colon = '\0';
                            param_t *pm = &fn->params[fn->param_count++];
                            strncpy(pm->name, tok, MAX_NAME - 1);
                            trim(pm->name);
                            strncpy(pm->type, colon + 1, MAX_NAME - 1);
                            trim(pm->type);
                        }
                        tok = strtok(NULL, ",");
                    }

                    char *arrow = strstr(rp + 1, "->");
                    if (arrow) {
                        char *ret = arrow + 2;
                        char *attr = strchr(ret, '[');
                        if (attr) *attr = '\0';
                        trim(ret);
                        strncpy(fn->return_type, ret, MAX_NAME - 1);
                    } else {
                        strcpy(fn->return_type, "void");
                    }

                    if (strstr(line, "[pure]")) fn->is_pure = 1;
                    if (strstr(line, "[extern]")) fn->is_extern = 1;
                }
            }
        }
    }

    fclose(f);
    return 0;
}

static int generate_sig_h(const char *outdir, const char *prefix) {
    char path[MAX_PATH];
    snprintf(path, sizeof(path), "%s/%s_ffi.h", outdir, prefix);

    FILE *out = fopen(path, "w");
    if (!out) return -1;

    char upper[MAX_NAME];
    strncpy(upper, prefix, MAX_NAME - 1);
    to_upper(upper);

    time_t now = time(NULL);
    fprintf(out, "/* AUTO-GENERATED by siggen %s */\n", SIGGEN_VERSION);
    fprintf(out, "/* @generated %s */\n\n", ctime(&now));
    fprintf(out, "#ifndef %s_FFI_H\n#define %s_FFI_H\n\n", upper, upper);
    fprintf(out, "#include <stdint.h>\n#include <stddef.h>\n\n");

    for (int i = 0; i < mod.func_count; i++) {
        func_t *fn = &mod.funcs[i];
        if (fn->is_pure) fprintf(out, "__attribute__((pure)) ");
        fprintf(out, "%s %s_%s(", sig_to_c(fn->return_type), prefix, fn->name);
        for (int j = 0; j < fn->param_count; j++) {
            fprintf(out, "%s %s", sig_to_c(fn->params[j].type), fn->params[j].name);
            if (j < fn->param_count - 1) fprintf(out, ", ");
        }
        if (fn->param_count == 0) fprintf(out, "void");
        fprintf(out, ");\n");
    }

    fprintf(out, "\n#endif /* %s_FFI_H */\n", upper);
    fclose(out);
    fprintf(stderr, "Generated %s\n", path);
    return 0;
}

static void print_usage(void) {
    fprintf(stderr, "siggen %s — Function Signature Generator\n", SIGGEN_VERSION);
    fprintf(stderr, "Usage: siggen <input.sig> [output_dir] [prefix]\n");
}

int main(int argc, char *argv[]) {
    if (argc < 2) { print_usage(); return 1; }

    const char *input = argv[1];
    const char *outdir = argc > 2 ? argv[2] : ".";

    char prefix[MAX_NAME];
    const char *basename = strrchr(input, '/');
    basename = basename ? basename + 1 : input;
    strncpy(prefix, basename, MAX_NAME - 1);
    char *dot = strchr(prefix, '.');
    if (dot) *dot = '\0';

    if (argc > 3) strncpy(prefix, argv[3], MAX_NAME - 1);

    if (parse_sig(input) != 0) return 1;

    fprintf(stderr, "Parsed module '%s' with %d functions\n", mod.name, mod.func_count);

    struct stat st;
    if (stat(outdir, &st) != 0) {
#ifdef _WIN32
        mkdir(outdir);
#else
        mkdir(outdir, 0755);
#endif
    }

    return generate_sig_h(outdir, prefix);
}
